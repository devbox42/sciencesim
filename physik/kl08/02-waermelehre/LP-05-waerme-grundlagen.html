<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LP-05: WÃ¤rme - Teilchenmodell, AggregatzustÃ¤nde & Temperatur</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f5;
            color: #222;
            font-size: 16px;
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #d32f2f 0%, #ff5722 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        header h1 {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        header .meta {
            font-size: 0.85em;
            opacity: 0.9;
        }

        /* Progress Bar */
        .progress-bar {
            background: rgba(255,255,255,0.3);
            height: 4px;
            margin-top: 15px;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            background: white;
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        /* Navigation */
        .nav-bar {
            background: white;
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .step-indicators {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .step-dot {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #e0e0e0;
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .step-dot.active {
            background: #d32f2f;
            color: white;
            transform: scale(1.1);
        }

        .step-dot.completed {
            background: #2a7a4b;
            color: white;
        }

        .nav-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .step-title {
            font-size: 0.85em;
            color: #555;
            text-align: center;
            flex: 1;
        }

        .nav-btn {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 0.9em;
            border-radius: 4px;
            min-width: 44px;
            min-height: 44px;
            touch-action: manipulation;
        }

        .nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .nav-btn:hover:not(:disabled) {
            background: #b71c1c;
        }

        /* Sections */
        .section {
            background: white;
            border: 1px solid #ddd;
            padding: 25px;
            margin-bottom: 20px;
            display: none;
            border-radius: 8px;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section h2 {
            font-size: 1.2em;
            font-weight: 600;
            color: #d32f2f;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #d32f2f;
        }

        .section h3 {
            font-size: 1em;
            font-weight: 600;
            margin: 20px 0 10px 0;
            color: #333;
        }

        .section p {
            margin-bottom: 12px;
        }

        /* Boxes */
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #1976d2;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .merke-box {
            background: #e8f5e9;
            border-left: 4px solid #2a7a4b;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .merke-box::before {
            content: "Merke";
            display: block;
            font-weight: 700;
            color: #2a7a4b;
            margin-bottom: 8px;
        }

        .warnung-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .hefter-hinweis {
            background: #fce4ec;
            border: 2px solid #d32f2f;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .hefter-hinweis::before {
            content: "Arbeitsblatt";
            display: block;
            font-weight: 700;
            color: #d32f2f;
            margin-bottom: 8px;
        }

        /* Formel-Box */
        .formel-box {
            background: linear-gradient(135deg, #fff 0%, #f5f5f5 100%);
            border: 2px solid #d32f2f;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            border-radius: 8px;
        }

        .formel-box .formel {
            font-size: 1.6em;
            font-weight: 600;
            color: #d32f2f;
            margin-bottom: 10px;
        }

        .formel-box .erklaerung {
            font-size: 0.9em;
            color: #555;
        }

        /* ISO 80000 */
        .fz { font-style: italic; }
        .einheit { font-style: normal; }

        /* Simulation Container */
        .sim-container {
            background: #e8edf2;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            position: relative;
            border: 1px solid #ccd5e0;
        }

        .sim-canvas {
            width: 100%;
            height: 300px;
            background: #f5f7fa;
            border-radius: 4px;
            display: block;
            border: 1px solid #d0d8e0;
        }

        .sim-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            align-items: center;
            justify-content: center;
        }

        .sim-control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .sim-control-group label {
            color: #555;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sim-slider {
            width: 150px;
            height: 8px;
            -webkit-appearance: none;
            background: #c5cdd8;
            border-radius: 4px;
            outline: none;
        }

        .sim-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #d32f2f;
            border-radius: 50%;
            cursor: pointer;
        }

        .sim-value {
            color: #d32f2f;
            font-size: 1.2em;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .sim-btn {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            min-height: 44px;
            touch-action: manipulation;
        }

        .sim-btn:hover {
            background: #b71c1c;
        }

        .sim-btn.active {
            background: #2a7a4b;
        }

        .sim-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .sim-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #555;
            font-size: 0.85em;
        }

        .sim-legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* State Cards */
        .state-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .state-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            touch-action: manipulation;
        }

        .state-card:hover, .state-card.active {
            border-color: #d32f2f;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .state-card .icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .state-card h4 {
            color: #d32f2f;
            margin-bottom: 8px;
        }

        .state-card p {
            font-size: 0.85em;
            color: #666;
            margin: 0;
        }

        /* Scale Comparison */
        .scale-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .scale {
            width: 80px;
            height: 300px;
            background: linear-gradient(to top, #2196f3, #f44336);
            border-radius: 8px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 0;
        }

        .scale-label {
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .scale-marker {
            position: absolute;
            right: -60px;
            font-size: 0.8em;
            white-space: nowrap;
        }

        .scale-pointer {
            position: absolute;
            left: -15px;
            width: 110px;
            height: 3px;
            background: #333;
            transition: top 0.3s;
        }

        .scale-pointer::before {
            content: '';
            position: absolute;
            left: 0;
            top: -5px;
            border-left: 8px solid #333;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }

        /* Quiz */
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .quiz-option {
            background: #f5f5f5;
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
            min-height: 44px;
        }

        .quiz-option:hover {
            border-color: #d32f2f;
            background: #fff;
        }

        .quiz-option.selected {
            border-color: #d32f2f;
            background: #ffebee;
        }

        .quiz-option.correct {
            border-color: #2a7a4b;
            background: #e8f5e9;
        }

        .quiz-option.incorrect {
            border-color: #d32f2f;
            background: #ffebee;
        }

        .quiz-feedback {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .quiz-feedback.show {
            display: block;
        }

        .quiz-feedback.correct {
            background: #e8f5e9;
            border: 1px solid #2a7a4b;
            color: #1b5e20;
        }

        .quiz-feedback.incorrect {
            background: #ffebee;
            border: 1px solid #d32f2f;
            color: #c62828;
        }

        /* Phase Diagram */
        .phase-diagram {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .phase-graph {
            width: 100%;
            height: 250px;
            position: relative;
        }

        /* LÃ¼ckentext */
        .luecke {
            display: inline-block;
            min-width: 100px;
            border-bottom: 2px solid #d32f2f;
            text-align: center;
            margin: 0 5px;
            padding: 2px 10px;
            background: #fff;
        }

        .luecke.filled {
            background: #e8f5e9;
            border-color: #2a7a4b;
        }

        /* Interactive Elements */
        .drag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            min-height: 60px;
        }

        .drag-item {
            background: #d32f2f;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: grab;
            touch-action: none;
            user-select: none;
        }

        .drag-item:active {
            cursor: grabbing;
        }

        .drop-zone {
            border: 2px dashed #aaa;
            padding: 15px;
            min-height: 60px;
            border-radius: 8px;
            margin: 10px 0;
            transition: all 0.2s;
        }

        .drop-zone.highlight {
            border-color: #d32f2f;
            background: #ffebee;
        }

        .drop-zone.correct {
            border-color: #2a7a4b;
            background: #e8f5e9;
        }

        /* Hypothesis & Prediction */
        .prediction-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .prediction-option {
            background: #f5f5f5;
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
            min-height: 44px;
        }

        .prediction-option:hover {
            border-color: #d32f2f;
            background: #fff;
        }

        .prediction-option.selected {
            border-color: #d32f2f;
            background: #ffebee;
            font-weight: 600;
        }

        .hypothesis-recall {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .hypothesis-recall::before {
            content: "RÃ¼ckblick auf deine Vermutung";
            display: block;
            font-weight: 700;
            color: #e65100;
            margin-bottom: 8px;
        }

        .hypothesis-recall .saved-text {
            font-style: italic;
            color: #555;
            margin-bottom: 10px;
        }

        .hypothesis-recall .result-text {
            color: #333;
        }

        /* Measurement Tables */
        .messwerttabelle {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .messwerttabelle th,
        .messwerttabelle td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .messwerttabelle th {
            background: #f5f5f5;
            font-size: 0.9em;
        }

        .messwert-input {
            width: 100%;
            max-width: 120px;
            padding: 6px 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
        }

        .messwert-input:focus {
            border-color: #d32f2f;
            outline: none;
        }

        .messwert-select {
            padding: 6px 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            min-height: 36px;
        }

        .messwert-select:focus {
            border-color: #d32f2f;
            outline: none;
        }

        .messwerttabelle .correct-cell {
            background: #e8f5e9;
        }

        .messwerttabelle .incorrect-cell {
            background: #ffebee;
        }

        .check-btn {
            background: #2a7a4b;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            min-height: 44px;
            touch-action: manipulation;
            margin-top: 10px;
        }

        .check-btn:hover {
            background: #1b5e20;
        }

        /* Erkenntnisweg Label */
        .ew-label {
            display: inline-block;
            font-size: 0.7em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 3px 10px;
            border-radius: 3px;
            margin-bottom: 8px;
        }

        .ew-phaenomen { background: #e3f2fd; color: #1565c0; }
        .ew-hypothese { background: #fff3e0; color: #e65100; }
        .ew-experiment { background: #fce4ec; color: #c62828; }
        .ew-beobachtung { background: #e8eaf6; color: #283593; }
        .ew-deutung { background: #e8f5e9; color: #2e7d32; }
        .ew-verallgemeinerung { background: #f3e5f5; color: #6a1b9a; }
        .ew-auswertung { background: #fff8e1; color: #f57f17; }
        .ew-zusammenfassung { background: #eceff1; color: #37474f; }

        /* Collapsible Fahrenheit */
        details.erweiterung {
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        details.erweiterung summary {
            background: #f5f5f5;
            padding: 15px;
            cursor: pointer;
            font-weight: 600;
            color: #555;
            min-height: 44px;
            touch-action: manipulation;
        }

        details.erweiterung summary:hover {
            background: #eee;
        }

        details.erweiterung > div {
            padding: 15px;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container { padding: 10px; }
            .section { padding: 15px; }
            .sim-canvas { height: 250px; }
            .scale-container { gap: 15px; }
            .scale { width: 60px; height: 250px; }
        }

        /* Sensor Button */
        .sensor-btn-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 200;
        }
        .sensor-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #455a64;
            color: white;
            border: none;
            font-size: 1.5em;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .sensor-btn:active { transform: scale(0.95); }
        .sensor-btn.active { background: #2a7a4b; }
        .sensor-btn.denied { background: #999; cursor: not-allowed; }
    </style>
</head>
<body>
    <header>
        <h1>WÃ¤rme: Teilchenmodell & Temperatur</h1>
        <div class="meta">Physik Klasse 8 | ca. 60-90 Minuten</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </header>

    <div class="container">
        <nav class="nav-bar">
            <div class="step-indicators" id="stepIndicators"></div>
            <div class="nav-controls">
                <button class="nav-btn" id="prevBtn" onclick="prevStep()">ZurÃ¼ck</button>
                <div class="step-title" id="stepTitle">Einstieg</div>
                <button class="nav-btn" id="nextBtn" onclick="nextStep()">Weiter</button>
            </div>
        </nav>


        <!-- ============================================================ -->
        <!-- ZYKLUS 1: Was ist Temperatur auf Teilchenebene?              -->
        <!-- ============================================================ -->

        <!-- SECTION 1: PhÃ¤nomen -->
        <section class="section active" data-step="1" data-title="PhÃ¤nomen: Was ist WÃ¤rme?">
            <div class="ew-label ew-phaenomen">PhÃ¤nomen</div>
            <h2>1. Einstieg: Was ist eigentlich WÃ¤rme?</h2>

            <p>Stell dir vor: Du kommst im Winter von drauÃŸen rein. Deine HÃ¤nde sind eiskalt. Du hÃ¤ltst sie an die warme Heizung...</p>

            <div class="info-box">
                <strong>Beobachtung:</strong> Nach kurzer Zeit werden deine HÃ¤nde warm. Die Heizung "gibt WÃ¤rme ab".
            </div>

            <p>Aber was genau passiert da? Was IST WÃ¤rme? Warum wird etwas warm oder kalt?</p>

            <p>Um das zu verstehen, mÃ¼ssen wir ganz tief in die Materie schauen - buchstÃ¤blich auf die <strong>kleinsten Teilchen</strong>.</p>

            <div class="hefter-hinweis">
                <strong>Aufgabe 1 auf dem AB:</strong> Notiere drei Situationen aus deinem Alltag, in denen etwas warm oder kalt wird.
            </div>
        </section>

        <!-- SECTION 2: Hypothese -->
        <section class="section" data-step="2" data-title="Deine Vermutung">
            <div class="ew-label ew-hypothese">Hypothese</div>
            <h2>2. Deine Vermutung</h2>

            <p>Bevor wir das Geheimnis der WÃ¤rme experimentell erforschen, wollen wir festhalten, was du <strong>bereits vermutest</strong>:</p>

            <div class="info-box">
                <strong>Forscherfrage:</strong> Was glaubst du â€“ was genau passiert, wenn etwas warm wird? Was ist â€WÃ¤rme" auf der kleinsten Ebene?
            </div>

            <h3>Was denkst du: Was ist Temperatur?</h3>
            <p>WÃ¤hle die Aussage, die deiner Vermutung am nÃ¤chsten kommt (es gibt kein â€richtig" oder â€falsch" â€“ wir prÃ¼fen es spÃ¤ter!):</p>
            <div class="prediction-options" id="prediction1">
                <div class="prediction-option" onclick="savePrediction1(this, 'A')">
                    A) Temperatur misst, wie viel von einem â€WÃ¤rmestoff" in einem KÃ¶rper steckt
                </div>
                <div class="prediction-option" onclick="savePrediction1(this, 'B')">
                    B) Temperatur misst, wie schnell sich die kleinsten Teilchen bewegen
                </div>
                <div class="prediction-option" onclick="savePrediction1(this, 'C')">
                    C) Temperatur misst, wie viele Teilchen in einem Stoff sind
                </div>
                <div class="prediction-option" onclick="savePrediction1(this, 'D')">
                    D) Temperatur ist einfach ein GefÃ¼hl und hat keine physikalische Ursache
                </div>
            </div>

            <div class="info-box">
                Klicke oben auf deine Vermutung â€” deine Wahl wird gespeichert und in Schritt 5 noch einmal angezeigt.
            </div>
        </section>

        <!-- SECTION 3: Experiment - Teilchen beobachten (Sim 1 + Sim 2) -->
        <section class="section" data-step="3" data-title="Experiment: Teilchen beobachten">
            <div class="ew-label ew-experiment">Experiment</div>
            <h2>3. Experiment: Teilchen beobachten</h2>

            <p>Alle Stoffe bestehen aus winzigen <strong>Teilchen</strong> (Atome oder MolekÃ¼le). Diese Teilchen sind so klein, dass wir sie nicht sehen kÃ¶nnen.</p>

            <div class="merke-box">
                <strong>Die drei Grundaussagen des Teilchenmodells:</strong>
                <ol style="margin: 10px 0 0 20px;">
                    <li>Alle Stoffe bestehen aus <strong>Teilchen</strong></li>
                    <li>Diese Teilchen sind in <strong>stÃ¤ndiger Bewegung</strong></li>
                    <li>Zwischen den Teilchen gibt es <strong>AnziehungskrÃ¤fte</strong></li>
                </ol>
            </div>

            <h3>Simulation 1: Teilchen in Bewegung</h3>
            <p>Stell dir vor, du hÃ¤ttest ein super-starkes Mikroskop und kÃ¶nntest tief in einen Stoff hineinschauen. Was wÃ¼rdest du sehen?</p>

            <div class="sim-container">
                <div style="position: relative;">
                    <canvas id="particleCanvas1" class="sim-canvas"></canvas>
                    <div id="macroOverlay" onclick="zoomIntoParticles()" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #bbdefb 0%, #90caf9 100%); display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer; transition: opacity 2s ease; border: 1px solid #d0d8e0;">
                        <div style="text-align: center;">
                            <div style="font-size: 3em;">ğŸ§Š</div>
                            <div style="font-size: 1.1em; font-weight: 600; color: #1565c0; margin-top: 8px;">Ein EiswÃ¼rfel auf dem Tisch</div>
                            <div style="font-size: 0.9em; color: #555; margin-top: 4px;">Alles scheint still zu stehen...</div>
                            <div style="margin-top: 15px; background: #d32f2f; color: white; padding: 10px 24px; border-radius: 4px; font-size: 0.9em; font-weight: 600; display: inline-block; min-height: 44px; line-height: 24px;">Hineinzoomen</div>
                        </div>
                    </div>
                </div>
                <div class="sim-controls">
                    <div class="sim-control-group">
                        <label>Temperatur</label>
                        <input type="range" class="sim-slider" id="speedSlider1" min="0" max="100" value="30">
                    </div>
                    <div class="sim-value" id="speedValue1">Kalt</div>
                    <button class="sim-btn" id="pauseBtn1" onclick="togglePause1()">Pause</button>
                </div>
                <div class="sim-legend">
                    <div class="sim-legend-item">
                        <div class="sim-legend-dot" style="background: #1565c0;"></div>
                        <span>Teilchen</span>
                    </div>
                    <div class="sim-legend-item">
                        <div class="sim-legend-dot" style="background: #e68a00; opacity: 0.6;"></div>
                        <span>Bindung</span>
                    </div>
                </div>
            </div>

            <div class="info-box">
                <strong>Wichtig:</strong> Selbst wenn ein Stoff vÃ¶llig ruhig erscheint, bewegen sich die Teilchen darin stÃ¤ndig! Diese Bewegung nennt man <strong>thermische Bewegung</strong> oder <strong>Brownsche Bewegung</strong>.
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 2 auf dem AB:</strong> VervollstÃ¤ndige die drei Grundaussagen des Teilchenmodells.
            </div>

            <h3>Die drei AggregatzustÃ¤nde</h3>

            <p>Je nachdem, wie stark die Teilchen aneinander gebunden sind und wie viel Energie sie haben, unterscheiden wir drei <strong>AggregatzustÃ¤nde</strong>:</p>

            <div class="state-cards">
                <div class="state-card" onclick="showState('fest')" id="card-fest">
                    <div class="icon">ğŸ§Š</div>
                    <h4>FEST</h4>
                    <p>Teilchen schwingen um feste PlÃ¤tze</p>
                </div>
                <div class="state-card" onclick="showState('fluessig')" id="card-fluessig">
                    <div class="icon">ğŸ’§</div>
                    <h4>FLÃœSSIG</h4>
                    <p>Teilchen gleiten aneinander vorbei</p>
                </div>
                <div class="state-card" onclick="showState('gasfoermig')" id="card-gasfoermig">
                    <div class="icon">ğŸ’¨</div>
                    <h4>GASFÃ–RMIG</h4>
                    <p>Teilchen fliegen frei umher</p>
                </div>
            </div>

            <h3>Simulation 2: Teilchen in verschiedenen AggregatzustÃ¤nden</h3>

            <div class="sim-container">
                <canvas id="stateCanvas" class="sim-canvas"></canvas>
                <div class="sim-controls">
                    <button class="sim-btn" id="btn-fest" onclick="setState('fest')">Fest</button>
                    <button class="sim-btn" id="btn-fluessig" onclick="setState('fluessig')">FlÃ¼ssig</button>
                    <button class="sim-btn" id="btn-gasfoermig" onclick="setState('gasfoermig')">GasfÃ¶rmig</button>
                </div>
                <div class="sim-legend">
                    <div class="sim-legend-item">
                        <div class="sim-legend-dot" style="background: #1565c0;"></div>
                        <span>Teilchen</span>
                    </div>
                    <div class="sim-legend-item">
                        <div class="sim-legend-dot" style="background: #ff9800; opacity: 0.5;"></div>
                        <span>Bindung (Anziehung)</span>
                    </div>
                </div>
            </div>

            <div id="stateDescription" class="info-box">
                Klicke auf einen Aggregatzustand, um die Teilchenbewegung zu sehen.
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 3 auf dem AB:</strong> Zeichne die Teilchenanordnung fÃ¼r jeden Aggregatzustand und beschreibe die Bewegung.
            </div>
        </section>

        <!-- SECTION 4: Beobachtung - Temperatur und Teilchen -->
        <section class="section" data-step="4" data-title="Beobachtung: Temperatur messen">
            <div class="ew-label ew-beobachtung">Beobachtung</div>
            <h2>4. Beobachtung: Temperatur und Teilchenbewegung</h2>

            <p>Jetzt untersuchen wir systematisch: <strong>Wie hÃ¤ngen Temperatur und Teilchenbewegung zusammen?</strong></p>
            <p>VerÃ¤ndere die Temperatur und beobachte, was mit den Teilchen passiert:</p>

            <h3>Simulation 3: Temperatur und Teilchenbewegung</h3>

            <div class="sim-container">
                <canvas id="tempCanvas" class="sim-canvas"></canvas>
                <div class="sim-controls">
                    <div class="sim-control-group">
                        <label>Temperatur</label>
                        <input type="range" class="sim-slider" id="tempSlider" min="-50" max="150" value="20">
                    </div>
                    <div class="sim-value" id="tempValue">20 Â°C</div>
                </div>
            </div>

            <div class="hefter-hinweis">
                <strong>Merke dir</strong> deine Beobachtungen â€” du brauchst sie fÃ¼r Aufgabe 4 auf dem AB.
            </div>
        </section>

        <!-- SECTION 5: Deutung - Was ist Temperatur? -->
        <section class="section" data-step="5" data-title="Deutung: Was ist Temperatur?">
            <div class="ew-label ew-deutung">Deutung</div>
            <h2>5. Deutung: Was ist Temperatur wirklich?</h2>

            <p>Du hast beobachtet: Je hÃ¶her die Temperatur, desto schneller bewegen sich die Teilchen. Was bedeutet das?</p>

            <div class="formel-box">
                <div class="formel">Temperatur = MaÃŸ fÃ¼r die mittlere kinetische Energie der Teilchen</div>
                <div class="erklaerung">Je schneller sich die Teilchen bewegen, desto hÃ¶her ist die Temperatur!</div>
            </div>

            <div class="merke-box">
                <ul style="margin-left: 20px;">
                    <li><strong>Hohe Temperatur</strong> = Teilchen bewegen sich schnell = viel kinetische Energie</li>
                    <li><strong>Niedrige Temperatur</strong> = Teilchen bewegen sich langsam = wenig kinetische Energie</li>
                </ul>
            </div>

            <h3>Quiz: Temperatur verstehen</h3>
            <div class="quiz-options" id="quiz1">
                <div class="quiz-option" onclick="checkQuiz1(this, false)">
                    A) Temperatur misst, wie viele Teilchen in einem Stoff sind
                </div>
                <div class="quiz-option" onclick="checkQuiz1(this, true)">
                    B) Temperatur ist ein MaÃŸ fÃ¼r die mittlere Bewegungsenergie der Teilchen
                </div>
                <div class="quiz-option" onclick="checkQuiz1(this, false)">
                    C) Temperatur misst, wie groÃŸ die Teilchen sind
                </div>
            </div>
            <div class="quiz-feedback" id="quiz1Feedback"></div>

            <div id="hypothesisRecall" class="hypothesis-recall" style="display: none;">
                <div class="saved-text" id="hypothesisRecallText"></div>
                <div class="result-text">
                    <strong>AuflÃ¶sung:</strong> Temperatur ist ein MaÃŸ fÃ¼r die mittlere <strong>Bewegungsenergie</strong> (kinetische Energie) der Teilchen. Lag deine Vermutung richtig?
                </div>
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 4 auf dem AB:</strong> ErklÃ¤re in eigenen Worten, was Temperatur auf Teilchenebene bedeutet.
            </div>
        </section>

        <!-- SECTION 6: Verallgemeinerung - Temperaturskalen -->
        <section class="section" data-step="6" data-title="Temperaturskalen: Celsius & Kelvin">
            <div class="ew-label ew-verallgemeinerung">Verallgemeinerung</div>
            <h2>6. Temperaturskalen: Celsius und Kelvin</h2>

            <h3>Die Celsius-Skala (Â°C)</h3>
            <p>Die Celsius-Skala wurde 1742 von Anders Celsius eingefÃ¼hrt. Sie basiert auf zwei Fixpunkten:</p>
            <ul style="margin: 10px 0 10px 25px;">
                <li><strong>0 Â°C</strong> = Schmelzpunkt von Eis (Wasser gefriert)</li>
                <li><strong>100 Â°C</strong> = Siedepunkt von Wasser (bei Normaldruck)</li>
            </ul>

            <h3>Die Kelvin-Skala (K)</h3>
            <p>Die Kelvin-Skala ist die <strong>wissenschaftliche Temperaturskala</strong>. Sie beginnt beim <strong>absoluten Nullpunkt</strong>:</p>

            <div class="formel-box">
                <div class="formel">0 K = âˆ’273 Â°C</div>
                <div class="erklaerung">Absoluter Nullpunkt: Hier bewegen sich die Teilchen (fast) gar nicht mehr!</div>
            </div>

            <div class="warnung-box">
                <strong>Wichtig:</strong> KÃ¤lter als 0 K geht nicht! Es gibt keine negative Kelvin-Temperatur, weil Teilchen nicht "weniger als gar keine" Bewegungsenergie haben kÃ¶nnen.
            </div>

            <h3>Umrechnung</h3>
            <div class="formel-box">
                <div class="formel"><span class="fz">T</span> / K = <span class="fz">Ï‘</span> / Â°C + 273</div>
                <div class="erklaerung">Kelvin = Celsius + 273 (fÃ¼r Ãœberschlagsrechnungen)</div>
            </div>

            <h3>Interaktiver Skalenvergleich</h3>
            <p>Ziehe den Regler und beobachte beide Skalen:</p>

            <div class="sim-container" style="padding: 15px;">
                <svg viewBox="0 0 440 300" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
                    <!-- CELSIUS THERMOMETER -->
                    <g transform="translate(105, 15)">
                        <defs>
                            <clipPath id="cClip"><rect x="3" y="2" width="14" height="216" rx="7"/></clipPath>
                        </defs>
                        <!-- Glass tube -->
                        <rect x="0" y="0" width="20" height="220" rx="10" fill="#f0f0f0" stroke="#aaa" stroke-width="1.5"/>
                        <!-- Bulb -->
                        <circle cx="10" cy="236" r="16" fill="#f0f0f0" stroke="#aaa" stroke-width="1.5"/>
                        <!-- Mercury tube -->
                        <rect id="celsiusMercury" x="3" y="84" width="14" height="136" fill="#d32f2f" clip-path="url(#cClip)"/>
                        <!-- Mercury bulb -->
                        <circle cx="10" cy="236" r="13" fill="#d32f2f"/>
                        <!-- Title -->
                        <text x="10" y="-6" text-anchor="middle" font-size="13" font-weight="700" fill="#d32f2f">Â°C</text>
                        <!-- Scale ticks left: y = (200 - temp) / 473 * 220 -->
                        <g font-size="9" fill="#777">
                            <line x1="-6" y1="0" x2="0" y2="0" stroke="#777"/>
                            <text x="-9" y="4" text-anchor="end">200</text>
                            <line x1="-6" y1="23.3" x2="0" y2="23.3" stroke="#ccc"/>
                            <line x1="-9" y1="46.5" x2="0" y2="46.5" stroke="#d32f2f" stroke-width="1.5"/>
                            <text x="-9" y="50" text-anchor="end" fill="#d32f2f" font-weight="600">100</text>
                            <line x1="-6" y1="69.8" x2="0" y2="69.8" stroke="#ccc"/>
                            <line x1="-9" y1="93" x2="0" y2="93" stroke="#1976d2" stroke-width="1.5"/>
                            <text x="-9" y="97" text-anchor="end" fill="#1976d2" font-weight="600">0</text>
                            <line x1="-6" y1="116.3" x2="0" y2="116.3" stroke="#ccc"/>
                            <line x1="-6" y1="139.5" x2="0" y2="139.5" stroke="#777"/>
                            <text x="-9" y="143" text-anchor="end">-100</text>
                            <line x1="-6" y1="162.8" x2="0" y2="162.8" stroke="#ccc"/>
                            <line x1="-6" y1="186" x2="0" y2="186" stroke="#777"/>
                            <text x="-9" y="190" text-anchor="end">-200</text>
                            <line x1="-9" y1="220" x2="0" y2="220" stroke="#333" stroke-width="1.5"/>
                            <text x="-9" y="224" text-anchor="end" fill="#333" font-weight="600">-273</text>
                        </g>
                        <!-- Reference labels right -->
                        <text x="26" y="50" font-size="8" fill="#d32f2f" font-weight="600">Siedepunkt Hâ‚‚O</text>
                        <text x="26" y="97" font-size="8" fill="#1976d2" font-weight="600">Gefrierpunkt Hâ‚‚O</text>
                        <text x="26" y="224" font-size="8" fill="#333">Absoluter Nullpunkt</text>
                    </g>

                    <!-- KELVIN THERMOMETER -->
                    <g transform="translate(305, 15)">
                        <defs>
                            <clipPath id="kClip"><rect x="3" y="2" width="14" height="216" rx="7"/></clipPath>
                        </defs>
                        <rect x="0" y="0" width="20" height="220" rx="10" fill="#f0f0f0" stroke="#aaa" stroke-width="1.5"/>
                        <circle cx="10" cy="236" r="16" fill="#f0f0f0" stroke="#aaa" stroke-width="1.5"/>
                        <rect id="kelvinMercury" x="3" y="84" width="14" height="136" fill="#1a237e" clip-path="url(#kClip)"/>
                        <circle cx="10" cy="236" r="13" fill="#1a237e"/>
                        <text x="10" y="-6" text-anchor="middle" font-size="13" font-weight="700" fill="#1a237e">K</text>
                        <!-- Scale ticks right -->
                        <g font-size="9" fill="#777">
                            <line x1="20" y1="0" x2="26" y2="0" stroke="#777"/>
                            <text x="29" y="4">473</text>
                            <line x1="20" y1="46.5" x2="26" y2="46.5" stroke="#777"/>
                            <text x="29" y="50">373</text>
                            <line x1="20" y1="93" x2="26" y2="93" stroke="#777"/>
                            <text x="29" y="97">273</text>
                            <line x1="20" y1="139.5" x2="26" y2="139.5" stroke="#777"/>
                            <text x="29" y="143">173</text>
                            <line x1="20" y1="186" x2="26" y2="186" stroke="#777"/>
                            <text x="29" y="190">73</text>
                            <line x1="20" y1="220" x2="29" y2="220" stroke="#333" stroke-width="1.5"/>
                            <text x="29" y="224" fill="#333" font-weight="600">0</text>
                        </g>
                        <text x="-6" y="224" text-anchor="end" font-size="8" fill="#333">Abs. Nullpunkt</text>
                    </g>

                    <!-- Connecting dashed line -->
                    <line id="connectLine" x1="125" y1="99" x2="305" y2="99" stroke="#999" stroke-width="1" stroke-dasharray="4,3"/>

                    <!-- Temperature displays -->
                    <text id="celsiusValue" x="115" y="290" text-anchor="middle" font-size="16" font-weight="700" fill="#d32f2f">20 Â°C</text>
                    <text id="kelvinValue" x="315" y="290" text-anchor="middle" font-size="16" font-weight="700" fill="#1a237e">293 K</text>
                </svg>
                <div class="sim-controls" style="padding-top: 5px;">
                    <div class="sim-control-group">
                        <label>Temperatur wÃ¤hlen</label>
                        <input type="range" class="sim-slider" id="scaleSlider" min="-273" max="200" value="20" style="width: 280px;">
                    </div>
                </div>
            </div>

            <h3>Wichtige Temperaturen</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <tr style="background: #f5f5f5;">
                    <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Temperatur</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Celsius</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Kelvin</th>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">Absoluter Nullpunkt</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">âˆ’273 Â°C</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">0 K</td>
                </tr>
                <tr style="background: #e3f2fd;">
                    <td style="padding: 10px; border: 1px solid #ddd;">Eis schmilzt</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">0 Â°C</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">273 K</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;">KÃ¶rpertemperatur</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">37 Â°C</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">310 K</td>
                </tr>
                <tr style="background: #ffebee;">
                    <td style="padding: 10px; border: 1px solid #ddd;">Wasser siedet</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">100 Â°C</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">373 K</td>
                </tr>
            </table>

            <div class="hefter-hinweis">
                <strong>Aufgabe 5 auf dem AB:</strong> Rechne folgende Temperaturen um: a) 25 Â°C in K, b) 350 K in Â°C, c) âˆ’40 Â°C in K
            </div>

            <details class="erweiterung">
                <summary>Erweiterung: Die Fahrenheit-Skala (aufklappen)</summary>
                <div>
                    <div class="info-box">
                        <strong>Zusatzwissen:</strong> In den USA wird die Fahrenheit-Skala verwendet. Sie wurde 1714 von Daniel Fahrenheit eingefÃ¼hrt.
                    </div>

                    <p>Fahrenheit wÃ¤hlte ungewÃ¶hnliche Fixpunkte:</p>
                    <ul style="margin: 10px 0 10px 25px;">
                        <li><strong>0 Â°F</strong> = KÃ¤lteste Temperatur, die er im Labor erzeugen konnte (Eis-Salz-Mischung)</li>
                        <li><strong>96 Â°F</strong> = KÃ¶rpertemperatur (ursprÃ¼nglich, spÃ¤ter korrigiert auf ~98 Â°F)</li>
                    </ul>

                    <p>Daraus ergibt sich:</p>
                    <ul style="margin: 10px 0 10px 25px;">
                        <li>Wasser gefriert bei <strong>32 Â°F</strong></li>
                        <li>Wasser siedet bei <strong>212 Â°F</strong></li>
                    </ul>

                    <h3>Umrechnung (fÃ¼r Interessierte)</h3>
                    <div class="formel-box">
                        <div class="formel"><span class="fz">Ï‘</span><sub>F</sub> = <sup>9</sup>â„<sub>5</sub> Â· <span class="fz">Ï‘</span><sub>C</sub> + 32</div>
                        <div class="erklaerung">Celsius â†’ Fahrenheit</div>
                    </div>
                    <div class="formel-box" style="margin-top: 8px;">
                        <div class="formel"><span class="fz">Ï‘</span><sub>C</sub> = <sup>5</sup>â„<sub>9</sub> Â· (<span class="fz">Ï‘</span><sub>F</sub> âˆ’ 32)</div>
                        <div class="erklaerung">Fahrenheit â†’ Celsius</div>
                    </div>

                    <div class="merke-box">
                        <strong>Merkhilfe:</strong> Bei âˆ’40Â° sind Celsius und Fahrenheit gleich! (âˆ’40 Â°C = âˆ’40 Â°F)
                    </div>

                    <div class="hefter-hinweis">
                        <strong>Aufgabe 6 (Erweiterung) auf dem AB:</strong> Recherchiere: Bei welcher Temperatur sind Celsius und Fahrenheit gleich? Warum?
                    </div>
                </div>
            </details>
        </section>

        <!-- ============================================================ -->
        <!-- ZYKLUS 2: Was passiert beim ErwÃ¤rmen von Eis zu Dampf?       -->
        <!-- ============================================================ -->

        <!-- SECTION 7: Neues PhÃ¤nomen - PhasenÃ¼bergÃ¤nge -->
        <section class="section" data-step="7" data-title="Neues PhÃ¤nomen: PhasenÃ¼bergÃ¤nge">
            <div class="ew-label ew-phaenomen">PhÃ¤nomen + Hypothese</div>
            <h2>7. Neues PhÃ¤nomen: Wenn Stoffe ihren Zustand Ã¤ndern</h2>

            <p>Wenn wir einem Stoff Energie (WÃ¤rme) zufÃ¼hren, bewegen sich die Teilchen schneller. Aber was passiert, wenn die Bindungen nicht mehr halten kÃ¶nnen?</p>

            <div class="formel-box">
                <div class="formel">Energie rein â†’ Bindungen brechen auf â†’ Aggregatzustand Ã¤ndert sich</div>
            </div>

            <h3>Die sechs PhasenÃ¼bergÃ¤nge</h3>

            <div style="text-align: center; margin: 20px 0;">
                <svg viewBox="0 0 500 350" style="max-width: 100%; height: auto;">
                    <defs>
                        <marker id="arrRed" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="userSpaceOnUse">
                            <polygon points="0 0, 8 3, 0 6" fill="#d32f2f"/>
                        </marker>
                        <marker id="arrBlue" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="userSpaceOnUse">
                            <polygon points="0 0, 8 3, 0 6" fill="#1976d2"/>
                        </marker>
                        <marker id="arrPurple" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="userSpaceOnUse">
                            <polygon points="0 0, 8 3, 0 6" fill="#7b1fa2"/>
                        </marker>
                        <marker id="arrTeal" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="userSpaceOnUse">
                            <polygon points="0 0, 8 3, 0 6" fill="#00838f"/>
                        </marker>
                    </defs>

                    <!-- GASFÃ–RMIG (Spitze oben) -->
                    <rect x="175" y="15" width="150" height="50" fill="#fff3e0" stroke="#e65100" stroke-width="2" rx="8"/>
                    <text x="250" y="45" text-anchor="middle" font-weight="700" font-size="14" fill="#e65100">GASFÃ–RMIG</text>

                    <!-- FEST (links unten) -->
                    <rect x="15" y="260" width="130" height="50" fill="#e3f2fd" stroke="#1565c0" stroke-width="2" rx="8"/>
                    <text x="80" y="290" text-anchor="middle" font-weight="700" font-size="14" fill="#1565c0">FEST</text>

                    <!-- FLÃœSSIG (rechts unten) -->
                    <rect x="355" y="260" width="130" height="50" fill="#e8f5e9" stroke="#2a7a4b" stroke-width="2" rx="8"/>
                    <text x="420" y="290" text-anchor="middle" font-weight="700" font-size="14" fill="#2a7a4b">FLÃœSSIG</text>

                    <!-- Schmelzen: fest â†’ flÃ¼ssig (unten, oben) -->
                    <line x1="145" y1="277" x2="353" y2="277" stroke="#d32f2f" stroke-width="2" marker-end="url(#arrRed)"/>
                    <text x="250" y="268" text-anchor="middle" font-size="11" font-weight="600" fill="#d32f2f">Schmelzen</text>

                    <!-- Erstarren: flÃ¼ssig â†’ fest (unten, unten) -->
                    <line x1="355" y1="295" x2="147" y2="295" stroke="#1976d2" stroke-width="2" marker-end="url(#arrBlue)"/>
                    <text x="250" y="325" text-anchor="middle" font-size="11" font-weight="600" fill="#1976d2">Erstarren</text>

                    <!-- Sublimieren: fest â†’ gasfÃ¶rmig (links) -->
                    <line x1="48" y1="260" x2="190" y2="67" stroke="#7b1fa2" stroke-width="2" marker-end="url(#arrPurple)"/>
                    <text x="78" y="152" text-anchor="end" font-size="11" font-weight="600" fill="#7b1fa2">Sublimieren</text>

                    <!-- Resublimieren: gasfÃ¶rmig â†’ fest (links) -->
                    <line x1="208" y1="67" x2="98" y2="260" stroke="#00838f" stroke-width="2" marker-end="url(#arrTeal)"/>
                    <text x="175" y="178" text-anchor="start" font-size="11" font-weight="600" fill="#00838f">Resublimieren</text>

                    <!-- Verdampfen: flÃ¼ssig â†’ gasfÃ¶rmig (rechts) -->
                    <line x1="452" y1="260" x2="310" y2="67" stroke="#d32f2f" stroke-width="2" marker-end="url(#arrRed)"/>
                    <text x="422" y="152" text-anchor="start" font-size="11" font-weight="600" fill="#d32f2f">Verdampfen</text>

                    <!-- Kondensieren: gasfÃ¶rmig â†’ flÃ¼ssig (rechts) -->
                    <line x1="292" y1="67" x2="402" y2="260" stroke="#1976d2" stroke-width="2" marker-end="url(#arrBlue)"/>
                    <text x="325" y="178" text-anchor="end" font-size="11" font-weight="600" fill="#1976d2">Kondensieren</text>

                    <!-- Energie-Legende -->
                    <text x="250" y="346" text-anchor="middle" font-size="10" fill="#999">rot = Energie zufÃ¼hren Â· blau = Energie abgeben</text>
                </svg>
            </div>

            <table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 0.95em;">
                <tr style="background: #f5f5f5;">
                    <th style="padding: 10px; border: 1px solid #ddd;">Ãœbergang</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Von â†’ Nach</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Energie</th>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Schmelzen</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">fest â†’ flÃ¼ssig</td>
                    <td style="padding: 10px; border: 1px solid #ddd; color: #d32f2f;">wird zugefÃ¼hrt</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Erstarren</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">flÃ¼ssig â†’ fest</td>
                    <td style="padding: 10px; border: 1px solid #ddd; color: #1976d2;">wird abgegeben</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Verdampfen</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">flÃ¼ssig â†’ gasfÃ¶rmig</td>
                    <td style="padding: 10px; border: 1px solid #ddd; color: #d32f2f;">wird zugefÃ¼hrt</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Kondensieren</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">gasfÃ¶rmig â†’ flÃ¼ssig</td>
                    <td style="padding: 10px; border: 1px solid #ddd; color: #1976d2;">wird abgegeben</td>
                </tr>
                <tr style="background: #f3e5f5;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Sublimieren</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">fest â†’ gasfÃ¶rmig</td>
                    <td style="padding: 10px; border: 1px solid #ddd; color: #d32f2f;">wird zugefÃ¼hrt</td>
                </tr>
                <tr style="background: #e0f7fa;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Resublimieren</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">gasfÃ¶rmig â†’ fest</td>
                    <td style="padding: 10px; border: 1px solid #ddd; color: #1976d2;">wird abgegeben</td>
                </tr>
            </table>

            <div class="info-box">
                <strong>Beispiele fÃ¼r Sublimation:</strong> Trockeneis (festes COâ‚‚), Gefrierbrand im TiefkÃ¼hler, Schnee verschwindet auch bei Minusgraden langsam
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 7 auf dem AB:</strong> Ordne die PhasenÃ¼bergÃ¤nge den Pfeilen im Diagramm zu.
            </div>

            <h3>Deine Vorhersage</h3>
            <p>Stell dir vor, du erhitzt einen Eisblock von âˆ’20 Â°C bis er komplett zu Dampf wird. <strong>Wie sieht die Temperaturkurve Ã¼ber die Zeit aus?</strong></p>
            <div class="prediction-options" id="prediction2">
                <div class="prediction-option" onclick="savePrediction2(this, 'A')">
                    A) Die Temperatur steigt gleichmÃ¤ÃŸig die ganze Zeit (gerade Linie)
                </div>
                <div class="prediction-option" onclick="savePrediction2(this, 'B')">
                    B) Die Temperatur steigt, bleibt bei 0 Â°C stehen (Plateau), steigt dann weiter
                </div>
                <div class="prediction-option" onclick="savePrediction2(this, 'C')">
                    C) Die Temperatur steigt, hat Plateaus bei 0 Â°C und 100 Â°C, steigt dazwischen
                </div>
                <div class="prediction-option" onclick="savePrediction2(this, 'D')">
                    D) Die Temperatur schwankt zufÃ¤llig hin und her
                </div>
            </div>
        </section>

        <!-- SECTION 8: Experiment - ErwÃ¤rmungskurve -->
        <section class="section" data-step="8" data-title="Simulationsexperiment: ErwÃ¤rmungskurve">
            <div class="ew-label ew-experiment">Simulationsexperiment</div>
            <h2>8. Simulationsexperiment: Die ErwÃ¤rmungskurve</h2>

            <p>Was passiert, wenn wir Eis von âˆ’20 Â°C langsam erhitzen â€” bis weit Ã¼ber 100 Â°C? In dieser Simulation beobachtest du den <strong>vollstÃ¤ndigen Verlauf</strong> und notierst die Messwerte auf deinem Arbeitsblatt.</p>

            <div class="info-box">
                <strong>Beobachtungsauftrag:</strong> Lies alle 30 Sekunden die Temperatur ab und trage sie in die Tabelle auf dem AB ein. Achte auf die Phasen, in denen sich die Temperatur <strong>nicht</strong> Ã¤ndert!
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 8 auf dem AB:</strong> Halte dein Arbeitsblatt bereit â€” notiere wÃ¤hrend der Simulation alle 30 Sekunden die Temperatur in die Tabelle und zeichne anschlieÃŸend die Kurve ins Diagramm.
            </div>

            <p>Die Simulation zeigt ein Becherglas mit Thermometer auf einer Heizplatte. Die Uhr lÃ¤uft â€” alle 30 Sekunden erscheint ein Messpunkt im Diagramm.</p>

            <h3>Simulation 4: ErwÃ¤rmungskurve von Wasser</h3>

            <div class="sim-container">
                <canvas id="heatingCanvas" class="sim-canvas" style="height: 400px;"></canvas>
                <div class="sim-controls">
                    <button class="sim-btn" id="startHeating" onclick="startHeatingSimulation()">Heizung einschalten</button>
                    <button class="sim-btn" onclick="resetHeatingSimulation()">ZurÃ¼cksetzen</button>
                    <div class="sim-value" id="heatingClock" style="font-family: monospace; font-size: 1.2em;">0:00 / 5:00</div>
                    <div class="sim-value" id="currentTemp">âˆ’20 Â°C</div>
                    <div class="sim-value" id="currentState" style="color: #1565c0;">Eis</div>
                </div>
            </div>
        </section>

        <!-- SECTION 9: Auswertung -->
        <section class="section" data-step="9" data-title="Auswertung: Messwerte analysieren">
            <div class="ew-label ew-auswertung">Auswertung</div>
            <h2>9. Auswertung: Die ErwÃ¤rmungskurve analysieren</h2>

            <p>Du hast die ErwÃ¤rmungskurve beobachtet. Gehe ggf. zurÃ¼ck zur Simulation und schaue dir den Verlauf noch einmal genau an.</p>

            <div class="info-box">
                <strong>Beobachtungsauftrag:</strong> Bei welchen Temperaturen bleibt die Kurve flach (Plateau)? Was passiert dort mit den Teilchen?
            </div>

            <h3>Messprotokoll: ErwÃ¤rmungskurve</h3>
            <p>Trage die wichtigsten Beobachtungen aus der Simulation in die Tabelle ein:</p>

            <table class="messwerttabelle" id="heatingMeasurements">
                <thead>
                    <tr>
                        <th>Abschnitt</th>
                        <th>Temperatur</th>
                        <th>Aggregatzustand</th>
                        <th>Was passiert?</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Start</td>
                        <td>
                            <input type="text" class="messwert-input" data-row="0" data-col="temp" placeholder="... Â°C" onchange="saveHeatingMeasurement(this)">
                        </td>
                        <td>
                            <select class="messwert-select" data-row="0" data-col="state" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="fest">fest</option>
                                <option value="flÃ¼ssig">flÃ¼ssig</option>
                                <option value="gasfÃ¶rmig">gasfÃ¶rmig</option>
                            </select>
                        </td>
                        <td>
                            <select class="messwert-select" data-row="0" data-col="event" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="erwÃ¤rmt sich">erwÃ¤rmt sich</option>
                                <option value="schmilzt">schmilzt (Plateau)</option>
                                <option value="siedet">siedet (Plateau)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>1. Plateau</td>
                        <td>
                            <input type="text" class="messwert-input" data-row="1" data-col="temp" placeholder="... Â°C" onchange="saveHeatingMeasurement(this)">
                        </td>
                        <td>
                            <select class="messwert-select" data-row="1" data-col="state" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="fest">fest</option>
                                <option value="fest â†’ flÃ¼ssig">fest â†’ flÃ¼ssig</option>
                                <option value="flÃ¼ssig">flÃ¼ssig</option>
                                <option value="flÃ¼ssig â†’ gasfÃ¶rmig">flÃ¼ssig â†’ gasfÃ¶rmig</option>
                                <option value="gasfÃ¶rmig">gasfÃ¶rmig</option>
                            </select>
                        </td>
                        <td>
                            <select class="messwert-select" data-row="1" data-col="event" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="erwÃ¤rmt sich">erwÃ¤rmt sich</option>
                                <option value="schmilzt">schmilzt (Plateau)</option>
                                <option value="siedet">siedet (Plateau)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Zwischen den Plateaus</td>
                        <td>
                            <input type="text" class="messwert-input" data-row="2" data-col="temp" placeholder="... bis ... Â°C" onchange="saveHeatingMeasurement(this)">
                        </td>
                        <td>
                            <select class="messwert-select" data-row="2" data-col="state" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="fest">fest</option>
                                <option value="flÃ¼ssig">flÃ¼ssig</option>
                                <option value="gasfÃ¶rmig">gasfÃ¶rmig</option>
                            </select>
                        </td>
                        <td>
                            <select class="messwert-select" data-row="2" data-col="event" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="erwÃ¤rmt sich">erwÃ¤rmt sich</option>
                                <option value="schmilzt">schmilzt (Plateau)</option>
                                <option value="siedet">siedet (Plateau)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>2. Plateau</td>
                        <td>
                            <input type="text" class="messwert-input" data-row="3" data-col="temp" placeholder="... Â°C" onchange="saveHeatingMeasurement(this)">
                        </td>
                        <td>
                            <select class="messwert-select" data-row="3" data-col="state" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="fest">fest</option>
                                <option value="fest â†’ flÃ¼ssig">fest â†’ flÃ¼ssig</option>
                                <option value="flÃ¼ssig">flÃ¼ssig</option>
                                <option value="flÃ¼ssig â†’ gasfÃ¶rmig">flÃ¼ssig â†’ gasfÃ¶rmig</option>
                                <option value="gasfÃ¶rmig">gasfÃ¶rmig</option>
                            </select>
                        </td>
                        <td>
                            <select class="messwert-select" data-row="3" data-col="event" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="erwÃ¤rmt sich">erwÃ¤rmt sich</option>
                                <option value="schmilzt">schmilzt (Plateau)</option>
                                <option value="siedet">siedet (Plateau)</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td>Ende</td>
                        <td>
                            <input type="text" class="messwert-input" data-row="4" data-col="temp" placeholder="... Â°C" onchange="saveHeatingMeasurement(this)">
                        </td>
                        <td>
                            <select class="messwert-select" data-row="4" data-col="state" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="fest">fest</option>
                                <option value="flÃ¼ssig">flÃ¼ssig</option>
                                <option value="gasfÃ¶rmig">gasfÃ¶rmig</option>
                            </select>
                        </td>
                        <td>
                            <select class="messwert-select" data-row="4" data-col="event" onchange="saveHeatingMeasurement(this)">
                                <option value="">-- wÃ¤hlen --</option>
                                <option value="erwÃ¤rmt sich">erwÃ¤rmt sich</option>
                                <option value="schmilzt">schmilzt (Plateau)</option>
                                <option value="siedet">siedet (Plateau)</option>
                            </select>
                        </td>
                    </tr>
                </tbody>
            </table>
            <button class="check-btn" onclick="checkHeatingMeasurements()">Auswertung prÃ¼fen</button>
            <div class="quiz-feedback" id="heatingMeasurementFeedback"></div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 8 auf dem AB:</strong> Werte dein Messprotokoll aus. Markiere das Plateau in deinem Diagramm und erklÃ¤re, warum die Temperatur dort konstant bleibt.
            </div>
        </section>

        <!-- SECTION 10: Deutung - Plateau & Verdunsten -->
        <section class="section" data-step="10" data-title="Deutung: Plateau & Verdunsten">
            <div class="ew-label ew-deutung">Deutung</div>
            <h2>10. Deutung: Das Geheimnis des Plateaus</h2>

            <div class="merke-box">
                <strong>Die groÃŸe Erkenntnis:</strong><br>
                WÃ¤hrend eines PhasenÃ¼bergangs bleibt die Temperatur <strong>konstant</strong>, obwohl weiter Energie zugefÃ¼hrt wird!<br><br>
                <strong>Warum?</strong> Die Energie wird nicht zur ErhÃ¶hung der Teilchenbewegung verwendet, sondern zum <strong>Aufbrechen der Bindungen</strong> zwischen den Teilchen!
            </div>

            <div class="formel-box">
                <div class="formel">Energie â†’ Bindungen aufbrechen (nicht: Temperatur erhÃ¶hen)</div>
                <div class="erklaerung">Deshalb: Plateau im Temperatur-Zeit-Diagramm bei Schmelz- und Siedepunkt</div>
            </div>

            <h3>Quiz: Das Plateau verstehen</h3>
            <p>Was passiert mit der zugefÃ¼hrten Energie wÃ¤hrend des Schmelzvorgangs (Plateau)?</p>
            <div class="quiz-options" id="quiz2">
                <div class="quiz-option" onclick="checkQuiz2(this, false)">
                    A) Sie geht verloren
                </div>
                <div class="quiz-option" onclick="checkQuiz2(this, false)">
                    B) Sie erhÃ¶ht die Temperatur weiter
                </div>
                <div class="quiz-option" onclick="checkQuiz2(this, true)">
                    C) Sie wird zum Aufbrechen der Bindungen zwischen den Teilchen verwendet
                </div>
                <div class="quiz-option" onclick="checkQuiz2(this, false)">
                    D) Sie wird von den Teilchen reflektiert
                </div>
            </div>
            <div class="quiz-feedback" id="quiz2Feedback"></div>

            <div id="predictionRecall" class="hypothesis-recall" style="display: none;">
                <div class="saved-text" id="predictionRecallText"></div>
                <div class="result-text">
                    <strong>AuflÃ¶sung:</strong> Die richtige Antwort war <strong>C</strong> â€“ die Temperatur hat Plateaus bei 0 Â°C (Schmelzen) und 100 Â°C (Sieden). Dort wird die Energie zum Aufbrechen der Bindungen verwendet, nicht zum ErwÃ¤rmen!
                </div>
            </div>

            <h3>Verdunsten vs. Sieden - Was ist der Unterschied?</h3>

            <p>Beide VorgÃ¤nge fÃ¼hren dazu, dass FlÃ¼ssigkeit zu Gas wird. Aber sie sind unterschiedlich:</p>

            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <tr style="background: #f5f5f5;">
                    <th style="padding: 12px; border: 1px solid #ddd; width: 20%;"></th>
                    <th style="padding: 12px; border: 1px solid #ddd;">Verdunsten</th>
                    <th style="padding: 12px; border: 1px solid #ddd;">Sieden</th>
                </tr>
                <tr>
                    <td style="padding: 12px; border: 1px solid #ddd;"><strong>Wo?</strong></td>
                    <td style="padding: 12px; border: 1px solid #ddd;">Nur an der <strong>OberflÃ¤che</strong></td>
                    <td style="padding: 12px; border: 1px solid #ddd;">In der <strong>gesamten FlÃ¼ssigkeit</strong></td>
                </tr>
                <tr>
                    <td style="padding: 12px; border: 1px solid #ddd;"><strong>Temperatur?</strong></td>
                    <td style="padding: 12px; border: 1px solid #ddd;">Bei <strong>jeder</strong> Temperatur</td>
                    <td style="padding: 12px; border: 1px solid #ddd;">Nur bei <strong>Siedetemperatur</strong></td>
                </tr>
                <tr>
                    <td style="padding: 12px; border: 1px solid #ddd;"><strong>Geschwindigkeit?</strong></td>
                    <td style="padding: 12px; border: 1px solid #ddd;">Langsam</td>
                    <td style="padding: 12px; border: 1px solid #ddd;">Schnell (Blasenbildung)</td>
                </tr>
                <tr>
                    <td style="padding: 12px; border: 1px solid #ddd;"><strong>Beispiel</strong></td>
                    <td style="padding: 12px; border: 1px solid #ddd;">WÃ¤sche trocknet</td>
                    <td style="padding: 12px; border: 1px solid #ddd;">Wasser im Topf kocht</td>
                </tr>
            </table>

            <div class="info-box">
                <strong>Alltagsbeispiel:</strong> Wenn du aus dem Schwimmbad kommst und der Wind weht, frierst du - obwohl es warm ist! Warum? Das Wasser auf deiner Haut verdunstet und entzieht deinem KÃ¶rper dabei Energie (VerdunstungskÃ¤lte).
            </div>

            <h3>Simulation 5: Verdunsten und Sieden</h3>

            <div class="sim-container">
                <canvas id="evapCanvas" class="sim-canvas"></canvas>
                <div class="sim-controls">
                    <button class="sim-btn" id="evapBtn" onclick="setEvapMode('evap')">Verdunsten (20 Â°C)</button>
                    <button class="sim-btn" id="boilBtn" onclick="setEvapMode('boil')">Sieden (100 Â°C)</button>
                </div>
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 9 auf dem AB:</strong> ErklÃ¤re, warum nasse Haut bei Wind kÃ¼hler wird als trockene Haut.
            </div>
        </section>

        <!-- SECTION 11: Zusammenfassung -->
        <section class="section" data-step="11" data-title="Zusammenfassung">
            <div class="ew-label ew-zusammenfassung">Zusammenfassung</div>
            <h2>11. Zusammenfassung: Das groÃŸe Ganze</h2>

            <div class="merke-box">
                <h3 style="margin-top: 0;">Die wichtigsten Erkenntnisse:</h3>
                <ol style="margin: 15px 0 0 20px;">
                    <li><strong>Teilchenmodell:</strong> Alle Stoffe bestehen aus Teilchen, die sich stÃ¤ndig bewegen.</li>
                    <li><strong>AggregatzustÃ¤nde:</strong> Fest (schwingen), FlÃ¼ssig (gleiten), GasfÃ¶rmig (fliegen) - je nach BindungsstÃ¤rke.</li>
                    <li><strong>Temperatur:</strong> MaÃŸ fÃ¼r die mittlere kinetische Energie der Teilchen.</li>
                    <li><strong>Kelvin-Skala:</strong> Beginnt beim absoluten Nullpunkt (0 K = âˆ’273 Â°C).</li>
                    <li><strong>PhasenÃ¼bergÃ¤nge:</strong> Energie wird zum Aufbrechen von Bindungen verwendet â†’ Temperatur bleibt konstant (Plateau).</li>
                </ol>
            </div>

            <h3>Finale Ãœbersicht</h3>

            <div style="text-align: center; margin: 20px 0; padding: 20px; background: #f5f5f5; border-radius: 8px;">
                <div style="font-size: 1.1em; margin-bottom: 15px;">
                    <strong>Teilchenmodell</strong><br>
                    â†“<br>
                    <strong>AggregatzustÃ¤nde</strong> (fest/flÃ¼ssig/gasfÃ¶rmig)<br>
                    â†“<br>
                    <strong>Temperatur</strong> = mittlere kinetische Energie<br>
                    â†“<br>
                    <strong>PhasenÃ¼bergÃ¤nge</strong> = Energie fÃ¼r Bindungsbruch<br>
                    â†“<br>
                    <strong>Plateau</strong> bei Schmelz-/Siedetemperatur
                </div>
            </div>

            <div class="hefter-hinweis">
                <strong>Aufgabe 10 auf dem AB:</strong> VervollstÃ¤ndige den LÃ¼ckentext zur Zusammenfassung.
            </div>

            <div style="text-align: center; margin-top: 30px; padding: 20px; background: #e8f5e9; border-radius: 8px;">
                <h3 style="color: #2a7a4b; margin-bottom: 10px;">Geschafft!</h3>
                <p>Du hast die Grundlagen der WÃ¤rmelehre gemeistert. In der nÃ¤chsten Stunde geht es weiter mit der <strong>WÃ¤rmeÃ¼bertragung</strong>.</p>
            </div>
        </section>
    </div>

    <!-- Sensor-Button (nur auf Touch-GerÃ¤ten sichtbar) -->
    <div class="sensor-btn-container" id="sensorContainer" style="display: none;">
        <button class="sensor-btn" id="sensorBtn" onclick="toggleSensor()" aria-label="Bewegungssensor aktivieren" title="iPad kippen & schÃ¼tteln">
            &#x1F4F1;
        </button>
    </div>

    <script>
        // ========== NAVIGATION ==========
        const sections = document.querySelectorAll('.section');
        const totalSteps = sections.length;
        let currentStep = 1;

        const stepTitles = [];
        sections.forEach((s, i) => {
            stepTitles.push(s.dataset.title || `Schritt ${i+1}`);
        });

        // Create step indicators
        const indicatorContainer = document.getElementById('stepIndicators');
        for (let i = 1; i <= totalSteps; i++) {
            const dot = document.createElement('div');
            dot.className = 'step-dot' + (i === 1 ? ' active' : '');
            dot.textContent = i;
            dot.onclick = () => goToStep(i);
            indicatorContainer.appendChild(dot);
        }

        function updateNavigation() {
            // Update dots
            document.querySelectorAll('.step-dot').forEach((dot, i) => {
                dot.classList.remove('active', 'completed');
                if (i + 1 === currentStep) dot.classList.add('active');
                else if (i + 1 < currentStep) dot.classList.add('completed');
            });

            // Update sections
            sections.forEach((s, i) => {
                s.classList.toggle('active', i + 1 === currentStep);
            });

            // Update title and buttons
            document.getElementById('stepTitle').textContent = stepTitles[currentStep - 1];
            document.getElementById('prevBtn').disabled = currentStep === 1;
            document.getElementById('nextBtn').disabled = currentStep === totalSteps;
            document.getElementById('nextBtn').textContent = currentStep === totalSteps ? 'Fertig' : 'Weiter';

            // Update progress
            document.getElementById('progressFill').style.width = ((currentStep / totalSteps) * 100) + '%';

            // Save progress
            localStorage.setItem('lp-08-waerme-step-v2', currentStep);
        }

        function goToStep(step) {
            if (step >= 1 && step <= totalSteps) {
                currentStep = step;
                updateNavigation();
                // Init canvas when section becomes visible (Sim â†’ Step mapping v2)
                requestAnimationFrame(() => {
                    if (step === 3 && canvas1.width === 0) { initParticles1(); initStateSimulation(); }
                    if (step === 3 && stateCanvas.width === 0) initStateSimulation();
                    if (step === 4 && tempCanvas.width === 0) initTempSimulation();
                    if (step === 8 && heatingCanvas.width === 0) initHeatingSimulation();
                    if (step === 10 && evapCanvas.width === 0) initEvapSimulation();
                });
                // Show recall boxes when arriving at interpretation sections
                if (step === 5) displayHypothesisRecall();
                if (step === 10) displayPrediction2Recall();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function nextStep() { goToStep(currentStep + 1); }
        function prevStep() { goToStep(currentStep - 1); }

        // Load saved progress
        const savedStep = localStorage.getItem('lp-08-waerme-step-v2');
        if (savedStep) goToStep(parseInt(savedStep));

        // ========== SHARED: Elastic collision ==========
        function resolveCollisions(particles) {
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i], p2 = particles[j];
                    const dx = p2.x - p1.x, dy = p2.y - p1.y;
                    const distSq = dx * dx + dy * dy;
                    const minDist = p1.r + p2.r;
                    if (distSq < minDist * minDist && distSq > 0.01) {
                        const dist = Math.sqrt(distSq);
                        const nx = dx / dist, ny = dy / dist;
                        // Separate (no overlap)
                        const overlap = (minDist - dist) / 2;
                        p1.x -= nx * overlap; p1.y -= ny * overlap;
                        p2.x += nx * overlap; p2.y += ny * overlap;
                        // Elastic velocity exchange
                        const dvx = p1.vx - p2.vx, dvy = p1.vy - p2.vy;
                        const dot = dvx * nx + dvy * ny;
                        if (dot > 0) {
                            p1.vx -= dot * nx; p1.vy -= dot * ny;
                            p2.vx += dot * nx; p2.vy += dot * ny;
                        }
                    }
                }
            }
        }

        // ========== DEVICE SENSOR MODULE ==========
        const DeviceSensor = (() => {
            let gravityX = 0;
            let gravityY = 1;   // default: downward
            let active = false;
            let denied = false;
            let shakeCount = 0;
            const consumed = {};
            let lastAccX = 0, lastAccY = 0, lastAccZ = 0;
            let lastShakeTime = 0;

            function startListening() {
                window.addEventListener('devicemotion', (e) => {
                    const g = e.accelerationIncludingGravity;
                    if (!g) return;
                    // Gravity direction (normalized -1..1)
                    gravityX = Math.max(-1, Math.min(1, -g.x / 9.81));
                    gravityY = Math.max(-1, Math.min(1, g.y / 9.81));
                    // Shake detection
                    const dx = Math.abs(g.x - lastAccX);
                    const dy = Math.abs(g.y - lastAccY);
                    const dz = Math.abs(g.z - lastAccZ);
                    lastAccX = g.x; lastAccY = g.y; lastAccZ = g.z;
                    const now = Date.now();
                    if (dx + dy + dz > 25 && now - lastShakeTime > 500) {
                        lastShakeTime = now;
                        shakeCount++;
                    }
                });
            }

            async function requestPermission() {
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    try {
                        const result = await DeviceMotionEvent.requestPermission();
                        if (result === 'granted') { active = true; startListening(); return true; }
                        denied = true; return false;
                    } catch (e) { denied = true; return false; }
                }
                active = true; startListening(); return true;
            }

            return {
                requestPermission,
                get gravityX() { return gravityX; },
                get gravityY() { return gravityY; },
                get active() { return active; },
                get denied() { return denied; },
                consumeShake(id) {
                    if (shakeCount > (consumed[id] || 0)) { consumed[id] = shakeCount; return true; }
                    return false;
                }
            };
        })();

        function getSensorGravity(baseGravity) {
            if (!DeviceSensor.active) return { gx: 0, gy: baseGravity };
            const mag = Math.sqrt(DeviceSensor.gravityX ** 2 + DeviceSensor.gravityY ** 2);
            const minMag = 0.3; // Minimum gravity when iPad is flat
            const scale = Math.max(minMag, mag);
            return {
                gx: DeviceSensor.gravityX * baseGravity * 2,
                gy: (mag < 0.1 ? 1 : DeviceSensor.gravityY / mag) * scale * baseGravity * 2
            };
        }

        async function toggleSensor() {
            if (DeviceSensor.active || DeviceSensor.denied) return;
            const granted = await DeviceSensor.requestPermission();
            const btn = document.getElementById('sensorBtn');
            if (granted) {
                btn.classList.add('active');
                btn.title = 'Sensor aktiv â€“ iPad kippen & schÃ¼tteln!';
            } else {
                btn.classList.add('denied');
                btn.title = 'Sensor nicht verfÃ¼gbar';
            }
        }

        // ========== SIMULATION 1: Eis (Feststoff) ==========
        const canvas1 = document.getElementById('particleCanvas1');
        const ctx1 = canvas1.getContext('2d');
        let particles1 = [];
        let paused1 = false;
        let speed1 = 30;
        let shakeBoost1 = 0;

        function initParticles1() {
            canvas1.width = canvas1.offsetWidth;
            canvas1.height = canvas1.offsetHeight;
            particles1 = [];
            // Solid: regular grid, particles nearly touching, sitting on bottom
            const cols = 9, rows = 5;
            const spacing = 24;
            const startX = canvas1.width / 2 - (cols - 1) * spacing / 2;
            const startY = canvas1.height - (rows * spacing) - 10;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    particles1.push({
                        x: startX + j * spacing,
                        y: startY + i * spacing,
                        baseX: startX + j * spacing,
                        baseY: startY + i * spacing,
                        vx: 0, vy: 0,
                        r: 8
                    });
                }
            }
        }

        function animateParticles1() {
            if (canvas1.width === 0 || canvas1.height === 0) {
                requestAnimationFrame(animateParticles1);
                return;
            }
            ctx1.fillStyle = '#f5f7fa';
            ctx1.fillRect(0, 0, canvas1.width, canvas1.height);

            if (DeviceSensor.consumeShake('sim1')) shakeBoost1 = 8;
            shakeBoost1 *= 0.95;
            const amplitude = (speed1 / 100) * 5 + shakeBoost1;
            const time = Date.now() / 400;

            // Tilt offset for solid grid
            let ox1 = 0, oy1 = 0;
            if (DeviceSensor.active) {
                ox1 = DeviceSensor.gravityX * 40;
                oy1 = (DeviceSensor.gravityY - 0.5) * 40;
            }

            // Update positions (oscillate around grid positions)
            if (!paused1) {
                particles1.forEach(p => {
                    p.x = p.baseX + ox1 + Math.sin(time + p.baseX * 0.13) * amplitude;
                    p.y = p.baseY + oy1 + Math.cos(time * 1.1 + p.baseY * 0.13) * amplitude;
                    p.x = Math.max(p.r, Math.min(canvas1.width - p.r, p.x));
                    p.y = Math.max(p.r, Math.min(canvas1.height - p.r, p.y));
                });
            }

            // Draw bonds between neighbors
            ctx1.strokeStyle = 'rgba(230, 130, 0, 0.4)';
            ctx1.lineWidth = 2;
            for (let i = 0; i < particles1.length; i++) {
                for (let j = i + 1; j < particles1.length; j++) {
                    const dx = particles1[j].baseX - particles1[i].baseX;
                    const dy = particles1[j].baseY - particles1[i].baseY;
                    const baseDist = Math.sqrt(dx*dx + dy*dy);
                    if (baseDist < 35) {
                        ctx1.beginPath();
                        ctx1.moveTo(particles1[i].x, particles1[i].y);
                        ctx1.lineTo(particles1[j].x, particles1[j].y);
                        ctx1.stroke();
                    }
                }
            }

            // Draw particles
            particles1.forEach(p => {
                ctx1.beginPath();
                ctx1.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx1.fillStyle = '#1565c0';
                ctx1.fill();
            });

            requestAnimationFrame(animateParticles1);
        }

        document.getElementById('speedSlider1').addEventListener('input', function() {
            speed1 = parseInt(this.value);
            const labels = ['Sehr kalt', 'Kalt', 'KÃ¼hl', 'Warm', 'HeiÃŸ'];
            const idx = Math.floor(this.value / 25);
            document.getElementById('speedValue1').textContent = labels[Math.min(idx, 4)];
        });

        function togglePause1() {
            paused1 = !paused1;
            document.getElementById('pauseBtn1').textContent = paused1 ? 'Fortsetzen' : 'Pause';
            document.getElementById('pauseBtn1').classList.toggle('active', paused1);
        }

        function zoomIntoParticles() {
            const overlay = document.getElementById('macroOverlay');
            overlay.style.opacity = '0';
            setTimeout(() => { overlay.style.display = 'none'; }, 2000);
        }

        // ========== SIMULATION 2: AggregatzustÃ¤nde ==========
        const stateCanvas = document.getElementById('stateCanvas');
        const stateCtx = stateCanvas.getContext('2d');
        let stateParticles = [];
        let currentState = 'fest';
        // Sliding physics for solid block
        let solidSlideX = 0, solidSlideVx = 0;

        const stateDescriptions = {
            fest: '<strong>Fester Zustand:</strong> Die Teilchen schwingen nur um ihre festen PlÃ¤tze. Sie sind durch starke BindungskrÃ¤fte fest miteinander verbunden und bilden eine regelmÃ¤ÃŸige Struktur (Gitter).',
            fluessig: '<strong>FlÃ¼ssiger Zustand:</strong> Die Teilchen kÃ¶nnen sich aneinander vorbeibewegen. Die Bindungen sind schwÃ¤cher, aber die Teilchen haben noch Kontakt zueinander. Die FlÃ¼ssigkeit sammelt sich am Boden und nimmt die Form des GefÃ¤ÃŸes an.',
            gasfoermig: '<strong>GasfÃ¶rmiger Zustand:</strong> Die Teilchen fliegen frei umher und stoÃŸen nur gelegentlich zusammen. Es gibt praktisch keine BindungskrÃ¤fte mehr. Sie verteilen sich im gesamten verfÃ¼gbaren Raum.'
        };

        function initStateSimulation() {
            stateCanvas.width = stateCanvas.offsetWidth;
            stateCanvas.height = stateCanvas.offsetHeight;
            setState('fest');
        }

        function setState(state) {
            currentState = state;
            stateParticles = [];

            // Update buttons
            ['fest', 'fluessig', 'gasfoermig'].forEach(s => {
                document.getElementById('btn-' + s).classList.toggle('active', s === state);
                document.getElementById('card-' + s).classList.toggle('active', s === state);
            });

            // Update description
            document.getElementById('stateDescription').innerHTML = stateDescriptions[state];

            const centerX = stateCanvas.width / 2;
            const centerY = stateCanvas.height / 2;

            solidSlideX = 0; solidSlideVx = 0;
            if (state === 'fest') {
                // Grid arrangement - particles nearly touching, sitting on bottom
                const cols = 8, rows = 5;
                const spacing = 23;
                const startX = centerX - (cols - 1) * spacing / 2;
                const startY = stateCanvas.height - (rows * spacing) - 10;

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        stateParticles.push({
                            x: startX + j * spacing,
                            y: startY + i * spacing,
                            baseX: startX + j * spacing,
                            baseY: startY + i * spacing,
                            vx: 0, vy: 0,
                            r: 10
                        });
                    }
                }
            } else if (state === 'fluessig') {
                // Particles in lower portion (liquid settles) - enough to fill ~half container
                for (let i = 0; i < 55; i++) {
                    stateParticles.push({
                        x: 30 + Math.random() * (stateCanvas.width - 60),
                        y: stateCanvas.height * 0.4 + Math.random() * (stateCanvas.height * 0.5),
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: (Math.random() - 0.5) * 1,
                        r: 10
                    });
                }
            } else {
                // Free moving
                for (let i = 0; i < 25; i++) {
                    stateParticles.push({
                        x: Math.random() * stateCanvas.width * 0.8 + stateCanvas.width * 0.1,
                        y: Math.random() * stateCanvas.height * 0.8 + stateCanvas.height * 0.1,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        r: 10
                    });
                }
            }
        }

        function animateState() {
            if (stateCanvas.width === 0 || stateCanvas.height === 0) {
                requestAnimationFrame(animateState);
                return;
            }
            stateCtx.fillStyle = '#f5f7fa';
            stateCtx.fillRect(0, 0, stateCanvas.width, stateCanvas.height);

            if (currentState === 'fest') {
                // Draw bonds first
                stateCtx.strokeStyle = 'rgba(230, 120, 0, 0.45)';
                stateCtx.lineWidth = 3;
                stateParticles.forEach((p, i) => {
                    stateParticles.forEach((p2, j) => {
                        if (j > i) {
                            const dx = p2.x - p.x;
                            const dy = p2.y - p.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 45) {
                                stateCtx.beginPath();
                                stateCtx.moveTo(p.x, p.y);
                                stateCtx.lineTo(p2.x, p2.y);
                                stateCtx.stroke();
                            }
                        }
                    });
                });

                // Solid block slides along bottom when tilted
                if (DeviceSensor.active) {
                    solidSlideVx += DeviceSensor.gravityX * 0.15; // tilt â†’ acceleration
                    solidSlideVx *= 0.96; // friction on surface
                }
                if (DeviceSensor.consumeShake('sim2-fest')) {
                    solidSlideVx += (Math.random() - 0.5) * 6;
                }
                solidSlideX += solidSlideVx;
                // Wall bounce
                const blockHalfW = 4 * 23; // ~half the grid width
                const minX = -stateCanvas.width / 2 + blockHalfW + 15;
                const maxX = stateCanvas.width / 2 - blockHalfW - 15;
                if (solidSlideX < minX) { solidSlideX = minX; solidSlideVx = -solidSlideVx * 0.3; }
                if (solidSlideX > maxX) { solidSlideX = maxX; solidSlideVx = -solidSlideVx * 0.3; }

                stateParticles.forEach(p => {
                    const time = Date.now() / 500;
                    p.x = p.baseX + solidSlideX + Math.sin(time + p.baseX) * 3;
                    p.y = p.baseY + Math.cos(time + p.baseY) * 3;
                    p.x = Math.max(p.r, Math.min(stateCanvas.width - p.r, p.x));
                    p.y = Math.max(p.r, Math.min(stateCanvas.height - p.r, p.y));
                });
            } else if (currentState === 'fluessig') {
                // Draw weak bonds
                stateCtx.strokeStyle = 'rgba(230, 120, 0, 0.3)';
                stateCtx.lineWidth = 2;
                stateParticles.forEach((p, i) => {
                    stateParticles.forEach((p2, j) => {
                        if (j > i) {
                            const dx = p2.x - p.x;
                            const dy = p2.y - p.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 40) {
                                stateCtx.beginPath();
                                stateCtx.moveTo(p.x, p.y);
                                stateCtx.lineTo(p2.x, p2.y);
                                stateCtx.stroke();
                            }
                        }
                    });
                });

                // Shake: impulse on liquid particles
                if (DeviceSensor.consumeShake('sim2')) {
                    stateParticles.forEach(p => { p.vx += (Math.random() - 0.5) * 6; p.vy += (Math.random() - 0.5) * 6; });
                }
                // Movement with gravity (liquid settles to bottom, surface stays horizontal)
                const gLiq = getSensorGravity(0.05);
                stateParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Gravity (liquid settles, sensor-aware)
                    p.vx += gLiq.gx;
                    p.vy += gLiq.gy;

                    // Random thermal jitter (particles still move!)
                    p.vx += (Math.random() - 0.5) * 0.3;
                    p.vy += (Math.random() - 0.5) * 0.2;

                    // Viscous damping
                    p.vx *= 0.99;
                    p.vy *= 0.99;

                    // Container walls
                    if (p.x < p.r + 5) { p.x = p.r + 5; p.vx = Math.abs(p.vx) * 0.5; }
                    if (p.x > stateCanvas.width - p.r - 5) { p.x = stateCanvas.width - p.r - 5; p.vx = -Math.abs(p.vx) * 0.5; }
                    if (p.y < p.r + 5) { p.y = p.r + 5; p.vy = Math.abs(p.vy) * 0.5; }
                    if (p.y > stateCanvas.height - p.r - 5) { p.y = stateCanvas.height - p.r - 5; p.vy = -Math.abs(p.vy) * 0.5; }
                });

                // Elastic collisions (no overlap)
                resolveCollisions(stateParticles);
            } else {
                // Gas - free movement
                if (DeviceSensor.consumeShake('sim2')) {
                    stateParticles.forEach(p => { p.vx += (Math.random() - 0.5) * 8; p.vy += (Math.random() - 0.5) * 8; });
                }
                const gGas = getSensorGravity(0.003);
                stateParticles.forEach(p => {
                    p.vx += gGas.gx; p.vy += gGas.gy;
                    p.x += p.vx;
                    p.y += p.vy;

                    if (p.x < p.r || p.x > stateCanvas.width - p.r) p.vx *= -1;
                    if (p.y < p.r || p.y > stateCanvas.height - p.r) p.vy *= -1;
                });
                resolveCollisions(stateParticles);
            }

            // Draw particles
            stateParticles.forEach(p => {
                stateCtx.beginPath();
                stateCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                stateCtx.fillStyle = '#1565c0';
                stateCtx.fill();
            });

            requestAnimationFrame(animateState);
        }

        function showState(state) {
            setState(state);
        }

        // ========== SIMULATION 3: Temperature ==========
        const tempCanvas = document.getElementById('tempCanvas');
        const tempCtx = tempCanvas.getContext('2d');
        let tempParticles = [];

        function initTempSimulation() {
            tempCanvas.width = tempCanvas.offsetWidth;
            tempCanvas.height = tempCanvas.offsetHeight;
            tempParticles = [];

            for (let i = 0; i < 30; i++) {
                tempParticles.push({
                    x: Math.random() * tempCanvas.width * 0.6 + tempCanvas.width * 0.2,
                    y: Math.random() * tempCanvas.height * 0.6 + tempCanvas.height * 0.2,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    r: 10
                });
            }
        }

        function animateTemp() {
            if (tempCanvas.width === 0 || tempCanvas.height === 0) {
                requestAnimationFrame(animateTemp);
                return;
            }
            tempCtx.fillStyle = '#f5f7fa';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            const temp = parseInt(document.getElementById('tempSlider').value);
            const speedFactor = Math.max(0.1, (temp + 273) / 300);

            // Color based on temperature
            let particleColor;
            if (temp < 0) {
                particleColor = `hsl(200, 80%, ${50 + temp/5}%)`;
            } else if (temp < 100) {
                particleColor = `hsl(${200 - temp * 1.5}, 80%, 60%)`;
            } else {
                particleColor = `hsl(${50 - (temp - 100) * 0.5}, 90%, 55%)`;
            }

            // Shake = Energiezufuhr (no tilt â€“ pedagogically pure Brownian motion)
            if (DeviceSensor.consumeShake('sim3')) {
                tempParticles.forEach(p => { p.vx += (Math.random() - 0.5) * 4; p.vy += (Math.random() - 0.5) * 4; });
            }

            tempParticles.forEach(p => {
                p.x += p.vx * speedFactor;
                p.y += p.vy * speedFactor;

                if (p.x < p.r || p.x > tempCanvas.width - p.r) p.vx *= -1;
                if (p.y < p.r || p.y > tempCanvas.height - p.r) p.vy *= -1;
            });

            resolveCollisions(tempParticles);

            tempParticles.forEach(p => {
                // Draw particle
                tempCtx.beginPath();
                tempCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                tempCtx.fillStyle = particleColor;
                tempCtx.fill();

                // Motion trail
                if (speedFactor > 0.5) {
                    tempCtx.beginPath();
                    tempCtx.moveTo(p.x, p.y);
                    tempCtx.lineTo(p.x - p.vx * speedFactor * 3, p.y - p.vy * speedFactor * 3);
                    tempCtx.strokeStyle = particleColor.replace(')', ', 0.3)').replace('hsl', 'hsla');
                    tempCtx.lineWidth = p.r;
                    tempCtx.stroke();
                }
            });

            // Draw temperature bar
            const barWidth = 30;
            const barHeight = tempCanvas.height - 40;
            const barX = tempCanvas.width - 50;
            const barY = 20;

            const gradient = tempCtx.createLinearGradient(0, barY + barHeight, 0, barY);
            gradient.addColorStop(0, '#2196f3');
            gradient.addColorStop(0.5, '#ffeb3b');
            gradient.addColorStop(1, '#f44336');

            tempCtx.fillStyle = gradient;
            tempCtx.fillRect(barX, barY, barWidth, barHeight);
            tempCtx.strokeStyle = '#555';
            tempCtx.strokeRect(barX, barY, barWidth, barHeight);

            // Indicator
            const tempPos = barY + barHeight - ((temp + 50) / 200) * barHeight;
            tempCtx.fillStyle = '#333';
            tempCtx.beginPath();
            tempCtx.moveTo(barX - 5, tempPos);
            tempCtx.lineTo(barX - 15, tempPos - 8);
            tempCtx.lineTo(barX - 15, tempPos + 8);
            tempCtx.fill();

            requestAnimationFrame(animateTemp);
        }

        document.getElementById('tempSlider').addEventListener('input', function() {
            document.getElementById('tempValue').textContent = this.value + ' Â°C';
        });

        // ========== SCALE COMPARISON ==========
        document.getElementById('scaleSlider').addEventListener('input', function() {
            const celsius = parseInt(this.value);
            const kelvin = celsius + 273;

            document.getElementById('celsiusValue').textContent = celsius + ' Â°C';
            document.getElementById('kelvinValue').textContent = kelvin + ' K';

            // Mercury height in SVG: tube is 220px tall, range -273 to 200 (473 steps)
            // y=0 is top of tube (200Â°C), y=220 is bottom (âˆ’273Â°C)
            const mercuryY = (200 - celsius) / 473 * 220;
            const mercuryH = 220 - mercuryY;

            document.getElementById('celsiusMercury').setAttribute('y', mercuryY);
            document.getElementById('celsiusMercury').setAttribute('height', mercuryH);
            document.getElementById('kelvinMercury').setAttribute('y', mercuryY);
            document.getElementById('kelvinMercury').setAttribute('height', mercuryH);

            // Update connecting dashed line (y offset by group translate y=15)
            const lineY = mercuryY + 15;
            document.getElementById('connectLine').setAttribute('y1', lineY);
            document.getElementById('connectLine').setAttribute('y2', lineY);
        });

                // ========== HEATING SIMULATION ==========
        const heatingCanvas = document.getElementById('heatingCanvas');
        const heatingCtx = heatingCanvas.getContext('2d');
        let virtualTime = 0;       // 0â€“300 virtual seconds (= 5 min)
        let heatingRunning = false;
        let heatingParticles = [];
        let heatingLastTs = 0;
        const HEATING_SPEED = 2.0;  // virtual s per real s â†’ ~2.5 min total

        function initHeatingSimulation() {
            heatingCanvas.width = heatingCanvas.offsetWidth;
            heatingCanvas.height = heatingCanvas.offsetHeight;
            resetHeatingSimulation();
        }

        function getTemperatureAtTime(t) {
            if (t <= 30)  return -20 + t * (20 / 30);
            if (t <= 120) return 0;
            if (t <= 210) return (t - 120) * (100 / 90);
            if (t <= 270) return 100;
            return Math.min(120, 100 + (t - 270) * (20 / 30));
        }

        function resetHeatingSimulation() {
            virtualTime = 0;
            heatingRunning = false;
            heatingLastTs = 0;
            document.getElementById('startHeating').textContent = 'Heizung einschalten';
            document.getElementById('heatingClock').textContent  = '0:00 / 5:00';
            document.getElementById('currentTemp').textContent   = '\u221220 \u00B0C';
            document.getElementById('currentState').textContent  = 'Eis';
            document.getElementById('currentState').style.color  = '#1565c0';
            const ch = heatingCanvas.height || 400;
            const bkL = 40, bkW = 90, bkB = ch - 60;
            heatingParticles = [];
            const cols = 5, rows = 4, sp = 15, r = 5;
            const gw = (cols - 1) * sp;
            const sx = bkL + (bkW - gw) / 2;
            const sy = bkB - rows * sp - 10;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const px = sx + j * sp, py = sy + i * sp;
                    heatingParticles.push({
                        x: px, y: py, baseX: px, baseY: py,
                        vx: 0, vy: 0, r: r,
                        melted: false, evaporated: false
                    });
                }
            }
        }

        function startHeatingSimulation() {
            if (virtualTime >= 300) { resetHeatingSimulation(); return; }
            if (!heatingRunning) {
                heatingRunning = true;
                document.getElementById('startHeating').textContent = 'Pause';
            } else {
                heatingRunning = false;
                document.getElementById('startHeating').textContent = 'Fortsetzen';
            }
        }

        function animateHeating(timestamp) {
            if (heatingCanvas.width === 0 || heatingCanvas.height === 0) {
                requestAnimationFrame(animateHeating); return;
            }
            if (!timestamp) timestamp = performance.now();
            const frameDt = heatingLastTs ? Math.min((timestamp - heatingLastTs) / 1000, 0.1) : 0;
            heatingLastTs = timestamp;
            const cw = heatingCanvas.width, ch = heatingCanvas.height;
            heatingCtx.fillStyle = '#f5f7fa';
            heatingCtx.fillRect(0, 0, cw, ch);

            if (heatingRunning && virtualTime < 300) {
                virtualTime += frameDt * HEATING_SPEED;
                if (virtualTime >= 300) {
                    virtualTime = 300;
                    heatingRunning = false;
                    document.getElementById('startHeating').textContent = 'Nochmal';
                }
            }

            const temp = getTemperatureAtTime(virtualTime);
            const tempR = Math.round(temp);
            document.getElementById('currentTemp').textContent = tempR + ' \u00B0C';
            const vm = Math.floor(virtualTime / 60), vs = Math.floor(virtualTime % 60);
            document.getElementById('heatingClock').textContent =
                vm + ':' + String(vs).padStart(2, '0') + ' / 5:00';

            let state, sc;
            if (virtualTime <= 30)       { state = 'Eis';            sc = '#1565c0'; }
            else if (virtualTime <= 120) { state = 'Schmelzen\u2026'; sc = '#1976d2'; }
            else if (virtualTime <= 210) { state = 'Wasser';         sc = '#1976d2'; }
            else if (virtualTime <= 270) { state = 'Sieden\u2026';   sc = '#e65100'; }
            else                         { state = 'Wasserdampf';    sc = '#bf360c'; }
            document.getElementById('currentState').textContent = state;
            document.getElementById('currentState').style.color = sc;

            // â”€â”€â”€â”€â”€ LAYOUT â”€â”€â”€â”€â”€
            const bCX = 85, bW = 90;
            const bL = bCX - bW / 2, bR = bCX + bW / 2;
            const bT = 40, bB = ch - 60, bH = bB - bT;
            const thX = 155, thT = bT, thB = bB + 10;
            const gL = 220, gTop = 25;
            const gW = cw - gL - 25, gH = ch - 70;

            // â”€â”€â”€â”€â”€ HEATER â”€â”€â”€â”€â”€
            const htY = bB + 5, htH = 14;
            const glow = heatingRunning ? 0.6 + Math.sin(Date.now() / 200) * 0.3 : 0.15;
            if (heatingRunning) {
                heatingCtx.fillStyle = 'rgba(255,87,34,' + (glow * 0.4) + ')';
                heatingCtx.fillRect(bL - 10, htY - 3, bW + 20, htH + 6);
            }
            heatingCtx.fillStyle = '#444';
            heatingCtx.fillRect(bL - 6, htY, bW + 12, htH);
            heatingCtx.strokeStyle = 'rgba(255,87,34,' + glow + ')';
            heatingCtx.lineWidth = 2;
            for (let ci = 0; ci < 3; ci++) {
                const cy = htY + 3 + ci * 4;
                heatingCtx.beginPath();
                for (let x = bL - 3; x <= bR + 3; x += 3) {
                    const yy = cy + Math.sin(x * 0.2) * 1.5;
                    x === bL - 3 ? heatingCtx.moveTo(x, yy) : heatingCtx.lineTo(x, yy);
                }
                heatingCtx.stroke();
            }

            // â”€â”€â”€â”€â”€ BEAKER GLASS â”€â”€â”€â”€â”€
            heatingCtx.strokeStyle = 'rgba(100,150,200,0.5)';
            heatingCtx.lineWidth = 3;
            heatingCtx.beginPath();
            heatingCtx.moveTo(bL - 2, bT - 5);
            heatingCtx.lineTo(bL, bB);
            heatingCtx.lineTo(bR, bB);
            heatingCtx.lineTo(bR + 2, bT - 5);
            heatingCtx.stroke();
            heatingCtx.lineWidth = 2;
            heatingCtx.beginPath();
            heatingCtx.moveTo(bL - 7, bT - 5);
            heatingCtx.lineTo(bL - 2, bT - 5);
            heatingCtx.moveTo(bR + 2, bT - 5);
            heatingCtx.lineTo(bR + 7, bT - 5);
            heatingCtx.stroke();

            // â”€â”€â”€â”€â”€ CONTENTS â”€â”€â”€â”€â”€
            let wFrac = 0, iFrac = 0;
            if (virtualTime <= 30) {
                iFrac = 0.55;
            } else if (virtualTime <= 120) {
                const mp = (virtualTime - 30) / 90;
                iFrac = 0.55 * (1 - mp);
                wFrac = 0.15 + 0.50 * mp;
            } else if (virtualTime <= 210) {
                wFrac = 0.65;                         // Wasser erwÃ¤rmt sich
            } else if (virtualTime <= 270) {
                const bp = (virtualTime - 210) / 60;  // 0â†’1 Ã¼ber Siede-Plateau
                wFrac = 0.65 * (1 - bp);              // Wasser sinkt linear auf 0
            } else {
                wFrac = 0;                             // Alles verdampft
            }

            if (iFrac > 0) {
                const iTop = bB - iFrac * bH;
                heatingCtx.fillStyle = 'rgba(180,215,240,0.6)';
                heatingCtx.fillRect(bL + 3, iTop, bW - 6, bB - iTop - 2);
                heatingCtx.strokeStyle = 'rgba(210,235,255,0.5)';
                heatingCtx.lineWidth = 1;
                for (let y = iTop + 8; y < bB - 4; y += 12)
                    for (let x = bL + 10; x < bR - 4; x += 12) {
                        heatingCtx.beginPath();
                        heatingCtx.moveTo(x - 3, y); heatingCtx.lineTo(x + 3, y);
                        heatingCtx.moveTo(x, y - 3); heatingCtx.lineTo(x, y + 3);
                        heatingCtx.stroke();
                    }
            }

            if (wFrac > 0) {
                const wTop = bB - (iFrac + wFrac) * bH;
                const wBot = iFrac > 0 ? bB - iFrac * bH : bB - 2;
                if (wTop < wBot) {
                    heatingCtx.fillStyle = 'rgba(100,165,220,0.25)';
                    heatingCtx.fillRect(bL + 3, wTop, bW - 6, wBot - wTop);
                    heatingCtx.strokeStyle = 'rgba(100,165,220,0.4)';
                    heatingCtx.lineWidth = 1.5;
                    heatingCtx.beginPath();
                    const wA = virtualTime > 210 ? 3 : 1;
                    for (let x = bL + 4; x <= bR - 4; x += 2) {
                        const wy = wTop + Math.sin((x + Date.now() / 500) * 0.12) * wA;
                        x === bL + 4 ? heatingCtx.moveTo(x, wy) : heatingCtx.lineTo(x, wy);
                    }
                    heatingCtx.stroke();
                }
            }

            // Bubbles
            if (virtualTime > 210 && virtualTime <= 300) {
                const nb = virtualTime > 270 ? 8 : 5;
                const wTop2 = bB - wFrac * bH;
                for (let i = 0; i < nb; i++) {
                    const bx = bL + 12 + (i * 15) % (bW - 20);
                    const ph = (Date.now() / 1000 + i * 0.7) % 1;
                    const by = bB - 8 - ph * Math.max(10, bB - wTop2 - 10);
                    const br = 2 + Math.sin(ph * Math.PI) * 2;
                    heatingCtx.beginPath();
                    heatingCtx.arc(bx, by, br, 0, Math.PI * 2);
                    heatingCtx.fillStyle = 'rgba(255,255,255,0.6)';
                    heatingCtx.fill();
                }
            }

            // Steam wisps
            if (virtualTime > 220) {
                const sOp = Math.min(0.3, (virtualTime - 220) / 100);
                for (let i = 0; i < 4; i++) {
                    const sx = bL + 12 + i * 20;
                    const ph = (Date.now() / 2000 + i * 0.3) % 1;
                    heatingCtx.beginPath();
                    heatingCtx.arc(sx + Math.sin(ph * Math.PI * 2) * 4,
                        bT - 8 - ph * 35, 4 + ph * 7, 0, Math.PI * 2);
                    heatingCtx.fillStyle = 'rgba(200,200,200,' + (sOp * (1 - ph)) + ')';
                    heatingCtx.fill();
                }
            }

            // â”€â”€â”€â”€â”€ PARTICLES â”€â”€â”€â”€â”€
            const pL = bL + 6, pR = bR - 6, pBo = bB - 4;
            let pTo;
            if (wFrac > 0) pTo = bB - (iFrac + wFrac) * bH;
            else if (iFrac > 0) pTo = bB - iFrac * bH;
            else pTo = bT + 5;

            if (virtualTime >= 30 && virtualTime < 120) {
                const mp = (virtualTime - 30) / 90;
                const targetMelted = Math.floor(mp * heatingParticles.length);
                const unmelted = heatingParticles.filter(p => !p.melted);
                const currentMelted = heatingParticles.length - unmelted.length;
                if (currentMelted < targetMelted && unmelted.length > 0) {
                    const p = unmelted[Math.floor(Math.random() * unmelted.length)];
                    p.melted = true;
                    p.vx = (Math.random() - 0.5) * 0.8;
                    p.vy = (Math.random() - 0.5) * 0.5;
                }
            } else if (virtualTime >= 120) {
                heatingParticles.forEach(p => { p.melted = true; });
            }

            if (virtualTime >= 210 && virtualTime < 270) {
                const bp = (virtualTime - 210) / 60;
                heatingParticles.forEach(p => {
                    if (!p.evaporated && Math.random() < 0.0008 + bp * 0.005) {
                        p.evaporated = true;
                        p.vx = (Math.random() - 0.5) * 2;
                        p.vy = -(Math.random() * 1.5 + 0.5);
                    }
                });
            } else if (virtualTime >= 270) {
                heatingParticles.forEach(p => { p.evaporated = true; });
            }

            // Bonds
            if (virtualTime < 120) {
                const solidCount = heatingParticles.filter(p => !p.melted).length;
                const bo = virtualTime < 30 ? 0.4 : 0.4 * (solidCount / heatingParticles.length);
                if (bo > 0.01) {
                    heatingCtx.strokeStyle = 'rgba(230,130,0,' + bo + ')';
                    heatingCtx.lineWidth = 1.5;
                    for (let i = 0; i < heatingParticles.length; i++) {
                        if (heatingParticles[i].melted) continue;
                        for (let j = i + 1; j < heatingParticles.length; j++) {
                            if (heatingParticles[j].melted) continue;
                            const ddx = heatingParticles[j].baseX - heatingParticles[i].baseX;
                            const ddy = heatingParticles[j].baseY - heatingParticles[i].baseY;
                            if (Math.sqrt(ddx * ddx + ddy * ddy) < 22) {
                                heatingCtx.beginPath();
                                heatingCtx.moveTo(heatingParticles[i].x, heatingParticles[i].y);
                                heatingCtx.lineTo(heatingParticles[j].x, heatingParticles[j].y);
                                heatingCtx.stroke();
                            }
                        }
                    }
                }
            }

            // Sensor gravity for heating sim
            const gSens = getSensorGravity(0.02);
            let hox = 0, hoy = 0;
            if (DeviceSensor.active) { hox = DeviceSensor.gravityX * 10; hoy = (DeviceSensor.gravityY - 0.5) * 10; }
            if (DeviceSensor.consumeShake('sim4')) {
                heatingParticles.forEach(p => { if (p.melted && !p.evaporated) { p.vx += (Math.random() - 0.5) * 4; p.vy += (Math.random() - 0.5) * 4; } });
            }

            heatingParticles.forEach(p => {
                if (!p.melted) {
                    const tt = Date.now() / 500;
                    const am = virtualTime < 30 ? 1 + (virtualTime / 30) * 2 : 3;
                    p.x = p.baseX + hox + Math.sin(tt + p.baseX * 0.2) * am;
                    p.y = p.baseY + hoy + Math.cos(tt * 1.1 + p.baseY * 0.2) * am;
                } else if (!p.evaporated) {
                    const ls = 0.4 + Math.max(0, temp) / 200;
                    const jt = 0.05 + Math.max(0, temp) / 800;
                    p.x += p.vx * ls; p.y += p.vy * ls;
                    p.vx += gSens.gx; p.vy += gSens.gy;
                    p.vx += (Math.random() - 0.5) * jt;
                    p.vy += (Math.random() - 0.5) * jt * 0.5;
                    p.vx *= 0.995; p.vy *= 0.995;
                } else {
                    p.x += p.vx * 1.2; p.y += p.vy * 1.2;
                    if (DeviceSensor.active) p.vx += DeviceSensor.gravityX * 0.01;
                }
                const boundTop = p.evaporated ? bT + 5 : pTo;
                if (p.x < pL + p.r) { p.x = pL + p.r; p.vx = Math.abs(p.vx) * 0.7; }
                if (p.x > pR - p.r) { p.x = pR - p.r; p.vx = -Math.abs(p.vx) * 0.7; }
                if (p.y < boundTop + p.r) { p.y = boundTop + p.r; p.vy = Math.abs(p.vy) * 0.7; }
                if (p.y > pBo - p.r) { p.y = pBo - p.r; p.vy = -Math.abs(p.vy) * 0.7; }
                heatingCtx.beginPath();
                heatingCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                heatingCtx.fillStyle = p.evaporated ? '#e65100' : sc;
                heatingCtx.fill();
            });
            resolveCollisions(heatingParticles);

            // â”€â”€â”€â”€â”€ THERMOMETER â”€â”€â”€â”€â”€
            const tw = 10, bulbR = 8, tHt = thB - thT;
            heatingCtx.fillStyle = '#eee';
            heatingCtx.fillRect(thX - tw / 2, thT, tw, tHt);
            heatingCtx.strokeStyle = '#aaa';
            heatingCtx.lineWidth = 1;
            heatingCtx.strokeRect(thX - tw / 2, thT, tw, tHt);
            const mFrac = Math.max(0, Math.min(1, (temp + 20) / 140));
            const mH = mFrac * (tHt - bulbR);
            heatingCtx.fillStyle = '#d32f2f';
            heatingCtx.fillRect(thX - tw / 2 + 2, thT + tHt - bulbR - mH, tw - 4, mH + bulbR);
            heatingCtx.beginPath();
            heatingCtx.arc(thX, thB + bulbR * 0.4, bulbR, 0, Math.PI * 2);
            heatingCtx.fillStyle = '#d32f2f';
            heatingCtx.fill();
            heatingCtx.strokeStyle = '#aaa';
            heatingCtx.stroke();
            // Scale ticks
            for (let d = -20; d <= 120; d += 20) {
                const f = (d + 20) / 140;
                const my = thT + tHt - bulbR - f * (tHt - bulbR);
                heatingCtx.beginPath();
                heatingCtx.moveTo(thX + tw / 2, my);
                heatingCtx.lineTo(thX + tw / 2 + 3, my);
                heatingCtx.strokeStyle = '#777';
                heatingCtx.lineWidth = 0.5;
                heatingCtx.stroke();
            }
            heatingCtx.fillStyle = '#555';
            heatingCtx.font = '8px sans-serif';
            heatingCtx.textAlign = 'left';
            [0, 100].forEach(d => {
                const f = (d + 20) / 140;
                const my = thT + tHt - bulbR - f * (tHt - bulbR);
                heatingCtx.fillText(d + '\u00B0', thX + tw / 2 + 5, my + 3);
            });

            // â”€â”€â”€â”€â”€ GRAPH â”€â”€â”€â”€â”€
            heatingCtx.fillStyle = '#f0f4f8';
            heatingCtx.fillRect(gL, gTop, gW, gH);
            const t2y = t => gTop + gH - ((t + 20) / 140) * gH;
            const s2x = s => gL + (s / 300) * gW;

            // Fine grid
            heatingCtx.strokeStyle = 'rgba(0,0,0,0.06)';
            heatingCtx.lineWidth = 0.5;
            for (let d = -20; d <= 120; d += 20) {
                heatingCtx.beginPath();
                heatingCtx.moveTo(gL, t2y(d));
                heatingCtx.lineTo(gL + gW, t2y(d));
                heatingCtx.stroke();
            }
            for (let s = 0; s <= 300; s += 30) {
                heatingCtx.beginPath();
                heatingCtx.moveTo(s2x(s), gTop);
                heatingCtx.lineTo(s2x(s), gTop + gH);
                heatingCtx.stroke();
            }

            // Dashed references
            heatingCtx.setLineDash([5, 5]);
            heatingCtx.lineWidth = 1;
            heatingCtx.strokeStyle = 'rgba(25,118,210,0.45)';
            heatingCtx.beginPath();
            heatingCtx.moveTo(gL, t2y(0)); heatingCtx.lineTo(gL + gW, t2y(0)); heatingCtx.stroke();
            heatingCtx.strokeStyle = 'rgba(211,47,47,0.45)';
            heatingCtx.beginPath();
            heatingCtx.moveTo(gL, t2y(100)); heatingCtx.lineTo(gL + gW, t2y(100)); heatingCtx.stroke();
            heatingCtx.setLineDash([]);

            // Ref labels
            heatingCtx.font = '9px sans-serif';
            heatingCtx.textAlign = 'left';
            heatingCtx.fillStyle = 'rgba(25,118,210,0.7)';
            heatingCtx.fillText('0 \u00B0C', gL + gW + 3, t2y(0) + 3);
            heatingCtx.fillStyle = 'rgba(211,47,47,0.7)';
            heatingCtx.fillText('100 \u00B0C', gL + gW + 3, t2y(100) + 3);

            // Plateau bands
            if (virtualTime > 30) {
                heatingCtx.fillStyle = 'rgba(25,118,210,0.07)';
                heatingCtx.fillRect(s2x(30), t2y(0) - 15,
                    s2x(Math.min(virtualTime, 120)) - s2x(30), 30);
            }
            if (virtualTime > 210) {
                heatingCtx.fillStyle = 'rgba(230,81,0,0.07)';
                heatingCtx.fillRect(s2x(210), t2y(100) - 15,
                    s2x(Math.min(virtualTime, 270)) - s2x(210), 30);
            }

            // Y labels
            heatingCtx.fillStyle = '#555';
            heatingCtx.font = '10px sans-serif';
            heatingCtx.textAlign = 'right';
            for (let d = -20; d <= 120; d += 20)
                heatingCtx.fillText(d + ' \u00B0C', gL - 4, t2y(d) + 4);

            // X labels
            heatingCtx.textAlign = 'center';
            for (let m = 0; m <= 5; m++)
                heatingCtx.fillText(m, s2x(m * 60), gTop + gH + 14);

            // Axis titles
            heatingCtx.save();
            heatingCtx.translate(gL - 38, gTop + gH / 2);
            heatingCtx.rotate(-Math.PI / 2);
            heatingCtx.textAlign = 'center';
            heatingCtx.font = '11px sans-serif';
            heatingCtx.fillStyle = '#333';
            heatingCtx.fillText('Temperatur \u03D1 / \u00B0C', 0, 0);
            heatingCtx.restore();
            heatingCtx.textAlign = 'center';
            heatingCtx.font = '11px sans-serif';
            heatingCtx.fillStyle = '#333';
            heatingCtx.fillText('Zeit t / min', gL + gW / 2, gTop + gH + 30);

            // Axes
            heatingCtx.strokeStyle = '#333';
            heatingCtx.lineWidth = 1.5;
            heatingCtx.beginPath();
            heatingCtx.moveTo(gL, gTop);
            heatingCtx.lineTo(gL, gTop + gH);
            heatingCtx.lineTo(gL + gW, gTop + gH);
            heatingCtx.stroke();

            // Curve
            heatingCtx.beginPath();
            heatingCtx.strokeStyle = '#d32f2f';
            heatingCtx.lineWidth = 2.5;
            for (let t = 0; t <= virtualTime; t += 0.5) {
                const px = s2x(t), py = t2y(getTemperatureAtTime(t));
                t === 0 ? heatingCtx.moveTo(px, py) : heatingCtx.lineTo(px, py);
            }
            heatingCtx.stroke();

            // 30 s measurement crosses
            let lastLabel = null;
            for (let s = 0; s <= 300; s += 30) {
                if (s > virtualTime) break;
                const mTemp = getTemperatureAtTime(s);
                const mx = s2x(s), my = t2y(mTemp);
                const cs = 5; // cross half-size
                heatingCtx.strokeStyle = '#d32f2f';
                heatingCtx.lineWidth = 2.5;
                heatingCtx.beginPath();
                heatingCtx.moveTo(mx - cs, my); heatingCtx.lineTo(mx + cs, my);
                heatingCtx.moveTo(mx, my - cs); heatingCtx.lineTo(mx, my + cs);
                heatingCtx.stroke();
                const rd = Math.round(mTemp);
                if (rd !== lastLabel) {
                    heatingCtx.fillStyle = '#333';
                    heatingCtx.font = '9px sans-serif';
                    heatingCtx.textAlign = 'center';
                    heatingCtx.fillText(rd + '\u00B0',
                        mx, my > gTop + gH * 0.5 ? my - 10 : my + 14);
                    lastLabel = rd;
                }
            }

            // Plateau labels
            if (virtualTime > 75) {
                heatingCtx.fillStyle = '#1565c0';
                heatingCtx.font = 'bold 10px sans-serif';
                heatingCtx.textAlign = 'center';
                heatingCtx.fillText('Schmelzen',
                    (s2x(30) + s2x(120)) / 2, t2y(0) - 20);
            }
            if (virtualTime > 240) {
                heatingCtx.fillStyle = '#e65100';
                heatingCtx.font = 'bold 10px sans-serif';
                heatingCtx.textAlign = 'center';
                heatingCtx.fillText('Sieden',
                    (s2x(210) + s2x(270)) / 2, t2y(100) - 20);
            }

            // Beaker label
            heatingCtx.fillStyle = '#666';
            heatingCtx.font = '10px sans-serif';
            heatingCtx.textAlign = 'center';
            heatingCtx.fillText('Becherglas', bCX, ch - 8);

            requestAnimationFrame(animateHeating);
        }

        // ========== EVAPORATION SIMULATION ==========
        const evapCanvas = document.getElementById('evapCanvas');
        const evapCtx = evapCanvas.getContext('2d');
        let evapParticles = [];
        let evapMode = 'evap';

        function initEvapSimulation() {
            evapCanvas.width = evapCanvas.offsetWidth;
            evapCanvas.height = evapCanvas.offsetHeight;
            setEvapMode('evap');
        }

        function setEvapMode(mode) {
            evapMode = mode;
            document.getElementById('evapBtn').classList.toggle('active', mode === 'evap');
            document.getElementById('boilBtn').classList.toggle('active', mode === 'boil');

            evapParticles = [];
            const waterLevel = evapCanvas.height * 0.5;

            // Liquid particles - densely fill the lower half
            for (let i = 0; i < 80; i++) {
                evapParticles.push({
                    x: 40 + Math.random() * (evapCanvas.width - 80),
                    y: waterLevel + 10 + Math.random() * (evapCanvas.height - waterLevel - 50),
                    vx: (Math.random() - 0.5) * (mode === 'boil' ? 4 : 1),
                    vy: (Math.random() - 0.5) * (mode === 'boil' ? 4 : 1),
                    r: 8,
                    type: 'liquid',
                    escapeChance: mode === 'boil' ? 0.01 : 0.002
                });
            }
        }

        function animateEvap() {
            if (evapCanvas.width === 0 || evapCanvas.height === 0) {
                requestAnimationFrame(animateEvap);
                return;
            }
            evapCtx.fillStyle = '#f5f7fa';
            evapCtx.fillRect(0, 0, evapCanvas.width, evapCanvas.height);

            const waterLevel = evapCanvas.height * 0.5;

            // Draw container (extends above water level for gas space)
            evapCtx.strokeStyle = '#777';
            evapCtx.lineWidth = 3;
            evapCtx.beginPath();
            evapCtx.moveTo(30, 40);
            evapCtx.lineTo(30, evapCanvas.height - 30);
            evapCtx.lineTo(evapCanvas.width - 30, evapCanvas.height - 30);
            evapCtx.lineTo(evapCanvas.width - 30, 40);
            evapCtx.stroke();

            // Water surface line
            evapCtx.strokeStyle = 'rgba(21, 101, 192, 0.4)';
            evapCtx.setLineDash([5, 5]);
            evapCtx.beginPath();
            evapCtx.moveTo(30, waterLevel);
            evapCtx.lineTo(evapCanvas.width - 30, waterLevel);
            evapCtx.stroke();
            evapCtx.setLineDash([]);

            // Label
            evapCtx.fillStyle = '#555';
            evapCtx.font = '12px sans-serif';
            evapCtx.fillText('OberflÃ¤che', evapCanvas.width - 80, waterLevel - 5);

            // Heater for boiling
            if (evapMode === 'boil') {
                const glow = 0.5 + Math.sin(Date.now() / 150) * 0.3;
                evapCtx.fillStyle = `rgba(255, 87, 34, ${glow})`;
                evapCtx.fillRect(30, evapCanvas.height - 30, evapCanvas.width - 60, 15);
            }

            // Shake: energy burst on surface particles
            if (DeviceSensor.consumeShake('sim5')) {
                evapParticles.forEach(p => {
                    if (p.type === 'liquid' && p.y < waterLevel + 30) {
                        p.vx += (Math.random() - 0.5) * 6;
                        p.vy -= Math.random() * 3;
                    }
                });
            }

            // Update particles
            const gE = getSensorGravity(0.02);
            evapParticles.forEach(p => {
                if (p.type === 'liquid') {
                    const speed = evapMode === 'boil' ? 2 : 0.5;
                    p.x += p.vx * speed;
                    p.y += p.vy * speed;
                    p.vx += gE.gx; p.vy += gE.gy; // sensor-aware gravity
                    p.vx *= 0.998; p.vy *= 0.998; // slight damping

                    // Boundaries
                    if (p.x < 40 || p.x > evapCanvas.width - 40) p.vx *= -1;
                    if (p.y > evapCanvas.height - 40) { p.vy *= -0.5; p.y = evapCanvas.height - 40; }

                    // At surface - chance to escape
                    if (p.y < waterLevel + 20) {
                        if (evapMode === 'evap') {
                            // Verdunsten - only at surface, slow
                            if (Math.random() < 0.003 && p.y < waterLevel + 10) {
                                p.type = 'gas';
                                p.vy = -Math.random() * 2 - 1;
                                p.vx = (Math.random() - 0.5) * 2;
                            } else {
                                p.vy = Math.abs(p.vy) * 0.5; // Bounce back gently
                            }
                        } else {
                            // Sieden - can escape from anywhere with bubbles
                            if (Math.random() < 0.015) {
                                p.type = 'gas';
                                p.vy = -Math.random() * 3 - 2;
                                p.vx = (Math.random() - 0.5) * 2;
                            }
                        }
                    }

                    // Bubbles in boiling
                    if (evapMode === 'boil' && p.y > waterLevel + 30 && Math.random() < 0.02) {
                        p.vy -= 0.5; // Bubble effect
                    }
                } else {
                    // Gas particle (subtle tilt drift)
                    if (DeviceSensor.active) { p.vx += DeviceSensor.gravityX * 0.005; p.vy += DeviceSensor.gravityY * 0.005; }
                    p.x += p.vx;
                    p.y += p.vy;

                    if (p.x < 10 || p.x > evapCanvas.width - 10) p.vx *= -1;
                    if (p.y < 10) p.vy *= -1;

                    // Disappear at top
                    if (p.y < 30) {
                        // Respawn as liquid
                        p.type = 'liquid';
                        p.x = 50 + Math.random() * (evapCanvas.width - 100);
                        p.y = waterLevel + Math.random() * (evapCanvas.height - waterLevel - 50);
                        p.vx = (Math.random() - 0.5) * 2;
                        p.vy = (Math.random() - 0.5) * 2;
                    }
                }

                // Draw
                evapCtx.beginPath();
                evapCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                evapCtx.fillStyle = p.type === 'liquid' ? '#1565c0' : '#e65100';
                evapCtx.fill();

                // Trail for gas
                if (p.type === 'gas') {
                    evapCtx.beginPath();
                    evapCtx.moveTo(p.x, p.y);
                    evapCtx.lineTo(p.x - p.vx * 3, p.y - p.vy * 3);
                    evapCtx.strokeStyle = 'rgba(230, 81, 0, 0.25)';
                    evapCtx.lineWidth = p.r;
                    evapCtx.stroke();
                }
            });

            // Collisions between all particles
            resolveCollisions(evapParticles);

            // Legend
            evapCtx.fillStyle = '#1565c0';
            evapCtx.beginPath();
            evapCtx.arc(50, 30, 8, 0, Math.PI * 2);
            evapCtx.fill();
            evapCtx.fillStyle = '#555';
            evapCtx.font = '12px sans-serif';
            evapCtx.fillText('FlÃ¼ssig', 65, 34);

            evapCtx.fillStyle = '#e65100';
            evapCtx.beginPath();
            evapCtx.arc(140, 30, 8, 0, Math.PI * 2);
            evapCtx.fill();
            evapCtx.fillStyle = '#555';
            evapCtx.fillText('GasfÃ¶rmig', 155, 34);

            requestAnimationFrame(animateEvap);
        }

        // ========== HYPOTHESES & PREDICTIONS ==========
        const LS_PREFIX = 'lp-08-waerme';

        function savePrediction1(element, choice) {
            // Deselect all, select this one
            document.querySelectorAll('#prediction1 .prediction-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            localStorage.setItem(LS_PREFIX + '-pred1', choice);
        }

        function savePrediction2(element, choice) {
            document.querySelectorAll('#prediction2 .prediction-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            localStorage.setItem(LS_PREFIX + '-pred2', choice);
        }

        function displayHypothesisRecall() {
            const pred = localStorage.getItem(LS_PREFIX + '-pred1');
            const recallBox = document.getElementById('hypothesisRecall');
            const recallText = document.getElementById('hypothesisRecallText');

            if (pred) {
                const labels = { A: 'WÃ¤rmestoff', B: 'Teilchenbewegung', C: 'Teilchenanzahl', D: 'Nur ein GefÃ¼hl' };
                recallText.innerHTML = '<strong>Deine Vorhersage war:</strong> ' + pred + ') ' + (labels[pred] || pred);
                recallBox.style.display = 'block';
            }
        }

        function displayPrediction2Recall() {
            const pred = localStorage.getItem(LS_PREFIX + '-pred2');
            const recallBox = document.getElementById('predictionRecall');
            const recallText = document.getElementById('predictionRecallText');

            if (pred) {
                const labels = {
                    A: 'GleichmÃ¤ÃŸiger Anstieg (gerade Linie)',
                    B: 'Ein Plateau bei 0 Â°C',
                    C: 'Plateaus bei 0 Â°C und 100 Â°C',
                    D: 'ZufÃ¤llige Schwankungen'
                };
                recallText.innerHTML = '<strong>Deine Vorhersage war:</strong> ' + pred + ') ' + (labels[pred] || pred);
                recallBox.style.display = 'block';
            }
        }

        function loadPredictions() {
            // Restore prediction 1
            const pred1 = localStorage.getItem(LS_PREFIX + '-pred1');
            if (pred1) {
                document.querySelectorAll('#prediction1 .prediction-option').forEach(opt => {
                    if (opt.textContent.trim().startsWith(pred1 + ')')) {
                        opt.classList.add('selected');
                    }
                });
            }
            // Restore prediction 2
            const pred2 = localStorage.getItem(LS_PREFIX + '-pred2');
            if (pred2) {
                document.querySelectorAll('#prediction2 .prediction-option').forEach(opt => {
                    if (opt.textContent.trim().startsWith(pred2 + ')')) {
                        opt.classList.add('selected');
                    }
                });
            }
        }

        // ========== MEASUREMENT TABLES ==========

        // --- Heating curve measurement table (Section 9) ---
        function saveHeatingMeasurement(el) {
            const row = el.dataset.row;
            const col = el.dataset.col;
            const value = el.tagName === 'SELECT' ? el.value : el.value;
            localStorage.setItem(LS_PREFIX + '-heat-' + row + '-' + col, value);
        }

        function loadHeatingMeasurements() {
            document.querySelectorAll('#heatingMeasurements [data-row]').forEach(el => {
                const saved = localStorage.getItem(LS_PREFIX + '-heat-' + el.dataset.row + '-' + el.dataset.col);
                if (saved) el.value = saved;
            });
        }

        function checkHeatingMeasurements() {
            const expected = [
                { temp: '-20', state: 'fest', event: 'erwÃ¤rmt sich' },
                { temp: '0', state: 'fest â†’ flÃ¼ssig', event: 'schmilzt' },
                { temp: '0 bis 100', state: 'flÃ¼ssig', event: 'erwÃ¤rmt sich' },
                { temp: '100', state: 'flÃ¼ssig â†’ gasfÃ¶rmig', event: 'siedet' },
                { temp: '120', state: 'gasfÃ¶rmig', event: 'erwÃ¤rmt sich' }
            ];

            let correct = 0;
            let total = 0;
            const rows = document.querySelectorAll('#heatingMeasurements tbody tr');

            rows.forEach((row, i) => {
                const inputs = row.querySelectorAll('input, select');
                inputs.forEach(el => {
                    const col = el.dataset.col;
                    const cell = el.closest('td');
                    cell.classList.remove('correct-cell', 'incorrect-cell');

                    if (el.value && el.value.trim()) {
                        total++;
                        const val = el.value.trim().toLowerCase().replace(/\s+/g, ' ').replace('Â°c', '').replace('âˆ’', '-').replace('â€“', '-');
                        const exp = expected[i][col].toLowerCase();

                        // Flexible matching for temperature inputs
                        let isCorrect = false;
                        if (col === 'temp') {
                            isCorrect = val.includes(exp.replace(' bis ', '')) || val === exp || val.replace(' ', '') === exp.replace(' ', '');
                        } else {
                            isCorrect = val === exp;
                        }

                        if (isCorrect) {
                            correct++;
                            cell.classList.add('correct-cell');
                        } else {
                            cell.classList.add('incorrect-cell');
                        }
                    }
                });
            });

            const feedback = document.getElementById('heatingMeasurementFeedback');
            if (total === 0) {
                feedback.className = 'quiz-feedback show incorrect';
                feedback.innerHTML = 'Bitte fÃ¼lle zuerst die Tabelle aus!';
            } else if (correct === total) {
                feedback.className = 'quiz-feedback show correct';
                feedback.innerHTML = '<strong>Ausgezeichnet!</strong> Du hast die ErwÃ¤rmungskurve korrekt analysiert. Die Plateaus zeigen, wo Energie fÃ¼r PhasenÃ¼bergÃ¤nge verwendet wird!';
            } else {
                feedback.className = 'quiz-feedback show incorrect';
                feedback.innerHTML = '<strong>' + correct + ' von ' + total + ' richtig.</strong> Gehe zurÃ¼ck zur Simulation (Sektion 8) und beobachte die Kurve noch einmal genau.';
            }
        }

        // ========== QUIZZES ==========
        function checkQuiz1(element, correct) {
            const options = document.querySelectorAll('#quiz1 .quiz-option');
            options.forEach(opt => {
                opt.style.pointerEvents = 'none';
                opt.classList.remove('selected');
            });

            element.classList.add(correct ? 'correct' : 'incorrect');

            const feedback = document.getElementById('quiz1Feedback');
            feedback.classList.add('show', correct ? 'correct' : 'incorrect');
            feedback.classList.remove(correct ? 'incorrect' : 'correct');
            feedback.innerHTML = correct
                ? '<strong>Richtig!</strong> Temperatur ist tatsÃ¤chlich ein MaÃŸ fÃ¼r die durchschnittliche Bewegungsenergie der Teilchen.'
                : '<strong>Nicht ganz.</strong> Denk daran: Temperatur hat mit der Bewegung der Teilchen zu tun, nicht mit ihrer Anzahl oder GrÃ¶ÃŸe.';
        }

        function checkQuiz2(element, correct) {
            const options = document.querySelectorAll('#quiz2 .quiz-option');
            options.forEach(opt => {
                opt.style.pointerEvents = 'none';
                opt.classList.remove('selected');
            });

            element.classList.add(correct ? 'correct' : 'incorrect');

            const feedback = document.getElementById('quiz2Feedback');
            feedback.classList.add('show', correct ? 'correct' : 'incorrect');
            feedback.classList.remove(correct ? 'incorrect' : 'correct');
            feedback.innerHTML = correct
                ? '<strong>Richtig!</strong> Die Energie wird verwendet, um die Bindungen zwischen den Teilchen zu lÃ¶sen. Deshalb steigt die Temperatur nicht, obwohl Energie zugefÃ¼hrt wird!'
                : '<strong>Nicht ganz.</strong> Die Energie geht nicht verloren - sie wird fÃ¼r einen anderen Zweck verwendet...';
        }

        // ========== INITIALIZATION ==========
        // Show sensor button on touch devices
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('sensorContainer').style.display = 'block';
        }

        window.addEventListener('load', () => {
            initParticles1();
            animateParticles1();

            initStateSimulation();
            animateState();

            initTempSimulation();
            animateTemp();

            initHeatingSimulation();
            animateHeating();

            initEvapSimulation();
            animateEvap();

            // Restore saved predictions and measurements
            loadPredictions();
            loadHeatingMeasurements();
        });

        window.addEventListener('resize', () => {
            if (canvas1.offsetWidth > 0) initParticles1();
            if (stateCanvas.offsetWidth > 0) initStateSimulation();
            if (tempCanvas.offsetWidth > 0) initTempSimulation();
            if (heatingCanvas.offsetWidth > 0) initHeatingSimulation();
            if (evapCanvas.offsetWidth > 0) initEvapSimulation();
        });
    </script>
</body>
</html>
